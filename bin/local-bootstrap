#!/usr/bin/env bash
set -euo pipefail

MODE="full"
DEFAULT_BASE_URL="https://codex-auth.uggs.io"

BASE_URL_SOURCE="default"
BASE_URL="$DEFAULT_BASE_URL"
if [[ -n "${CODEX_SYNC_BASE_URL:-}" ]]; then
  BASE_URL="${CODEX_SYNC_BASE_URL}"
  BASE_URL_SOURCE="env"
fi

INVITE_KEY_SOURCE="default"
INVITE_KEY="${CODEX_SYNC_INVITE_KEY:-}"
if [[ -n "$INVITE_KEY" ]]; then
  INVITE_KEY_SOURCE="env"
fi

API_KEY_SOURCE="default"
API_KEY="${CODEX_SYNC_API_KEY:-}"
if [[ -n "$API_KEY" ]]; then
  API_KEY_SOURCE="env"
fi

FQDN_DEFAULT="$(hostname -f 2>/dev/null || hostname 2>/dev/null || echo localhost)"
FQDN_SOURCE="default"
FQDN="${CODEX_SYNC_FQDN:-$FQDN_DEFAULT}"
if [[ -n "${CODEX_SYNC_FQDN:-}" ]]; then
  FQDN_SOURCE="env"
fi

CA_FILE_SOURCE="default"
CA_FILE="${CODEX_SYNC_CA_FILE:-}"
if [[ -n "$CA_FILE" ]]; then
  CA_FILE_SOURCE="env"
fi

ENV_PATH_DEFAULT="/usr/local/etc/codex-sync.env"
LOCAL_ENV_DEFAULT="$HOME/.codex/sync.env"
ENV_PATH="${CODEX_SYNC_ENV_PATH:-$ENV_PATH_DEFAULT}"
CUSTOM_ENV_PATH=0
if [[ -n "${CODEX_SYNC_ENV_PATH:-}" ]]; then
  CUSTOM_ENV_PATH=1
fi

WRAPPER_TARGET_DEFAULT="/usr/local/bin/cdx"
WRAPPER_TARGET="${CODEX_WRAPPER_TARGET:-$WRAPPER_TARGET_DEFAULT}"

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
REPO_ROOT="$(cd "${SCRIPT_DIR}/.." && pwd)"
WRAPPER_SOURCE="${SCRIPT_DIR}/cdx"
CURRENT_USER="$(id -un 2>/dev/null || whoami 2>/dev/null || echo user)"
CURRENT_GROUP="$(id -gn 2>/dev/null || echo "$CURRENT_USER")"

FORCE=0
USE_LOCAL_ENV=0
POSITIONAL_MODE=""

log() { printf '==> %s\n' "$1"; }
warn() { printf '!! %s\n' "$1" >&2; }
die() { printf 'Error: %s\n' "$1" >&2; exit 1; }
step() { printf '→ %s\n' "$1"; }
ok() { printf '✔ %s\n' "$1"; }
skip() { printf '↷ %s\n' "$1"; }

usage() {
  cat <<USAGE
Usage: ${0##*/} [mode] [options]

Modes:
  full            Install cdx and (re)register this host (default)
  cdx             Install/refresh only the cdx wrapper
  register        Re-register this host and rewrite the sync env

Options:
  --base-url <url>        Override sync API base URL (default: ${DEFAULT_BASE_URL})
  --invite-key <key>      Invitation key used for /register
  --invite-file <path>    Read the invitation key from a file
  --api-key <key>         Use an existing API key (skips register unless register mode)
  --fqdn <name>           Hostname sent during registration (default: ${FQDN_DEFAULT})
  --env-path <path>       Target sync env file (default: /usr/local/etc/codex-sync.env)
  --local-env             Shortcut for --env-path "${LOCAL_ENV_DEFAULT}"
  --ca-file <path>        Include a custom CA bundle for curl + env file
  --cdx-only              Alias for mode "cdx"
  --re-register           Alias for mode "register"
  --mode <mode>           Explicit mode selection
  --wrapper-target <path> Install cdx at a custom path (default: /usr/local/bin/cdx)
  --force                 Overwrite the sync env even if it already exists
  -h, --help              Show this help text

Environment variables: CODEX_SYNC_BASE_URL, CODEX_SYNC_INVITE_KEY, CODEX_SYNC_API_KEY,
CODEX_SYNC_FQDN, CODEX_SYNC_ENV_PATH, CODEX_SYNC_CA_FILE, CODEX_WRAPPER_TARGET.
USAGE
  exit "${1:-0}"
}

trim() {
  local value="$1"
  value="${value#${value%%[![:space:]]*}}"
  value="${value%${value##*[![:space:]]}}"
  printf '%s' "$value"
}

unquote() {
  local value="$1"
  if [[ "$value" == \"*\" && "$value" == *\" ]]; then
    value="${value:1:${#value}-2}"
  elif [[ "$value" == \'*\' && "$value" == *\' ]]; then
    value="${value:1:${#value}-2}"
  fi
  printf '%s' "$value"
}

normalize_base_url() {
  local url="$1"
  [[ -z "$url" ]] && { printf '%s' "$url"; return; }
  while [[ "$url" == */ && "$url" != "http://" && "$url" != "https://" ]]; do
    url="${url%/}"
  done
  printf '%s' "$url"
}

require_cmd() {
  local missing=()
  local cmd
  for cmd in "$@"; do
    if ! command -v "$cmd" >/dev/null 2>&1; then
      missing+=("$cmd")
    fi
  done
  if (( ${#missing[@]} > 0 )); then
    die "Missing required command(s): ${missing[*]}"
  fi
}

install_file_with_mode() {
  local src="$1"
  local dest="$2"
  local mode="$3"
  if install -D -m "$mode" "$src" "$dest" 2>/dev/null; then
    return 0
  fi
  if command -v sudo >/dev/null 2>&1; then
    sudo install -D -m "$mode" "$src" "$dest"
    return $?
  fi
  return 1
}

parse_env_file() {
  local file="$1"
  local line key value
  while IFS= read -r line || [[ -n "$line" ]]; do
    line="${line%%#*}"
    line="$(trim "$line")"
    [[ -z "$line" ]] && continue
    if [[ "$line" == export* ]]; then
      line="${line#export}"
      line="$(trim "$line")"
    fi
    [[ "$line" != *=* ]] && continue
    key="$(trim "${line%%=*}")"
    value="$(trim "${line#*=}")"
    value="$(unquote "$value")"
    case "$key" in
      CODEX_SYNC_BASE_URL)
        if [[ "$BASE_URL_SOURCE" == "default" ]]; then
          BASE_URL="$(normalize_base_url "$value")"
          BASE_URL_SOURCE="env-file"
        fi
        ;;
      CODEX_SYNC_API_KEY)
        if [[ "$API_KEY_SOURCE" == "default" ]]; then
          API_KEY="$value"
          API_KEY_SOURCE="env-file"
        fi
        ;;
      CODEX_SYNC_FQDN)
        if [[ "$FQDN_SOURCE" == "default" ]]; then
          FQDN="$value"
          FQDN_SOURCE="env-file"
        fi
        ;;
      CODEX_SYNC_CA_FILE)
        if [[ "$CA_FILE_SOURCE" == "default" ]]; then
          CA_FILE="$value"
          CA_FILE_SOURCE="env-file"
        fi
        ;;
    esac
  done <"$file"
}

load_existing_sync_env() {
  local candidates=()
  if (( CUSTOM_ENV_PATH )); then
    candidates+=("$ENV_PATH")
  else
    candidates+=("$ENV_PATH" "$LOCAL_ENV_DEFAULT" "/usr/local/etc/codex-sync.env")
  fi
  local file
  for file in "${candidates[@]}"; do
    [[ -r "$file" ]] || continue
    parse_env_file "$file"
    ENV_SOURCE_PATH="$file"
    log "Loaded existing sync env: $file"
    break
  done
}

extract_invite_key_from_doc() {
  local doc="${REPO_ROOT}/API.md"
  [[ -r "$doc" ]] || return 1
  local line
  line="$(grep -E 'Current onboarding key' "$doc" | head -n1 || true)"
  [[ -z "$line" ]] && return 1
  local key
  key="$(printf '%s' "$line" | sed -E 's/.*`([0-9a-f]+)`/\1/')"
  [[ -z "$key" ]] && return 1
  INVITE_KEY="$key"
  INVITE_KEY_SOURCE="doc"
  return 0
}

extract_invite_key_from_env() {
  local file="$1"
  [[ -r "$file" ]] || return 1
  local line value
  while IFS= read -r line || [[ -n "$line" ]]; do
    line="${line%%#*}"
    line="$(trim "$line")"
    [[ -z "$line" ]] && continue
    if [[ "$line" == export* ]]; then
      line="${line#export}"
      line="$(trim "$line")"
    fi
    [[ "$line" != INVITATION_KEY=* ]] && continue
    value="$(trim "${line#*=}")"
    value="$(unquote "$value")"
    if [[ -n "$value" ]]; then
      INVITE_KEY="$value"
      INVITE_KEY_SOURCE="dotenv"
      return 0
    fi
  done <"$file"
  return 1
}

ensure_invite_key() {
  if [[ -n "$INVITE_KEY" ]]; then
    return 0
  fi
  local dotenv_path="${REPO_ROOT}/.env"
  if extract_invite_key_from_env "$dotenv_path"; then
    return 0
  fi
  if extract_invite_key_from_doc; then
    return 0
  fi
  die "Invitation key required. Provide --invite-key or CODEX_SYNC_INVITE_KEY."
}

register_host() {
  ensure_invite_key
  [[ -n "$BASE_URL" ]] || die "Base URL is required for registration"
  require_cmd curl python3
  local url="$(normalize_base_url "$BASE_URL")/register"
  local payload
  payload="$(python3 -c 'import json, sys; print(json.dumps({"fqdn": sys.argv[1], "invitation_key": sys.argv[2]}))' "$FQDN" "$INVITE_KEY")"
  local response
  local curl_args=(-fsS -H 'Content-Type: application/json')
  if [[ -n "$CA_FILE" ]]; then
    curl_args+=(--cacert "$CA_FILE")
  fi
  curl_args+=(-d "$payload" "$url")
  if ! response="$(curl "${curl_args[@]}")"; then
    die "Registration request failed"
  fi
  if ! API_KEY="$(API_RESPONSE="$response" python3 - <<'PY'
import json, os, sys
data = json.loads(os.environ.get("API_RESPONSE", "{}"))
host = data.get("host") or data.get("data", {}).get("host") or {}
api_key = host.get("api_key") or data.get("api_key")
if not api_key:
    sys.exit(1)
print(api_key, end="")
PY
)"; then
    die "Register response missing api_key"
  fi
  API_KEY_SOURCE="register"
  log "Obtained new API key for ${FQDN}"
}

write_sync_env() {
  [[ -n "$API_KEY" ]] || die "Cannot write sync env without an API key"
  [[ -n "$BASE_URL" ]] || die "Base URL missing; cannot write sync env"
  local tmp
  tmp="$(mktemp)"
  {
    printf 'CODEX_SYNC_BASE_URL=%s\n' "$(normalize_base_url "$BASE_URL")"
    printf 'CODEX_SYNC_API_KEY=%s\n' "$API_KEY"
    if [[ -n "$FQDN" ]]; then
      printf 'CODEX_SYNC_FQDN=%s\n' "$FQDN"
    fi
    if [[ -n "$CA_FILE" ]]; then
      printf 'CODEX_SYNC_CA_FILE=%s\n' "$CA_FILE"
    fi
  } >"$tmp"
  if [[ "$ENV_PATH" == "$LOCAL_ENV_DEFAULT" ]]; then
    mkdir -p "${LOCAL_ENV_DEFAULT%/*}"
    chmod 700 "${LOCAL_ENV_DEFAULT%/*}" 2>/dev/null || true
  fi
  if install_file_with_mode "$tmp" "$ENV_PATH" 600; then
    log "Wrote sync env to $ENV_PATH"
  else
    rm -f "$tmp"
    die "Failed to write sync env at $ENV_PATH (try --local-env or run with sudo)"
  fi
  if [[ $(id -u) -ne 0 && -n "$CURRENT_USER" && ! -O "$ENV_PATH" ]] && command -v sudo >/dev/null 2>&1; then
    if ! sudo chown "$CURRENT_USER:$CURRENT_GROUP" "$ENV_PATH" >/dev/null 2>&1; then
      warn "Unable to change owner of $ENV_PATH; $CURRENT_USER may need sudo to read it"
    fi
  fi
  rm -f "$tmp"
}

install_cdx_wrapper() {
  [[ -r "$WRAPPER_SOURCE" ]] || die "Missing cdx wrapper at $WRAPPER_SOURCE"
  require_cmd install
  local tmp
  tmp="$(mktemp)"
  cp "$WRAPPER_SOURCE" "$tmp"
  chmod 755 "$tmp"
  if install_file_with_mode "$tmp" "$WRAPPER_TARGET" 755; then
    log "Installed cdx wrapper to $WRAPPER_TARGET"
  else
    rm -f "$tmp"
    die "Failed to install cdx wrapper at $WRAPPER_TARGET"
  fi
  rm -f "$tmp"
}

while [[ $# -gt 0 ]]; do
  case "$1" in
    full|cdx|register|re-register)
      POSITIONAL_MODE="$1"
      shift
      ;;
    --mode)
      MODE="$2"
      shift 2
      ;;
    --full)
      MODE="full"
      shift
      ;;
    --cdx|--cdx-only)
      MODE="cdx"
      shift
      ;;
    --register|--register-only|--re-register)
      MODE="register"
      shift
      ;;
    --base-url)
      BASE_URL="$2"
      BASE_URL_SOURCE="cli"
      shift 2
      ;;
    --invite-key)
      INVITE_KEY="$2"
      INVITE_KEY_SOURCE="cli"
      shift 2
      ;;
    --invite-file)
      [[ -r "$2" ]] || die "Invite file $2 missing"
      INVITE_KEY="$(<"$2")"
      INVITE_KEY="$(trim "$INVITE_KEY")"
      INVITE_KEY_SOURCE="file"
      shift 2
      ;;
    --api-key)
      API_KEY="$2"
      API_KEY_SOURCE="cli"
      shift 2
      ;;
    --fqdn)
      FQDN="$2"
      FQDN_SOURCE="cli"
      shift 2
      ;;
    --env-path)
      ENV_PATH="$2"
      CUSTOM_ENV_PATH=1
      shift 2
      ;;
    --local-env)
      ENV_PATH="$LOCAL_ENV_DEFAULT"
      CUSTOM_ENV_PATH=1
      USE_LOCAL_ENV=1
      shift
      ;;
    --ca-file)
      CA_FILE="$2"
      CA_FILE_SOURCE="cli"
      shift 2
      ;;
    --wrapper-target)
      WRAPPER_TARGET="$2"
      shift 2
      ;;
    --force)
      FORCE=1
      shift
      ;;
    -h|--help)
      usage 0
      ;;
    --)
      shift
      break
      ;;
    *)
      die "Unknown argument: $1"
      ;;
  esac
done

if [[ -n "$POSITIONAL_MODE" ]]; then
  case "$POSITIONAL_MODE" in
    full)
      MODE="full"
      ;;
    cdx)
      MODE="cdx"
      ;;
    register|re-register)
      MODE="register"
      ;;
  esac
fi

case "$MODE" in
  full|cdx|register)
    ;;
  *)
    die "Unsupported mode: $MODE"
    ;;
esac

BASE_URL="$(normalize_base_url "$BASE_URL")"
INVITE_KEY="$(trim "$INVITE_KEY")"
API_KEY="$(trim "$API_KEY")"
FQDN="$(trim "$FQDN")"
CA_FILE="$(trim "$CA_FILE")"

load_existing_sync_env

BASE_URL="$(normalize_base_url "$BASE_URL")"
if [[ -n "$CA_FILE" && ! -r "$CA_FILE" ]]; then
  warn "CA file $CA_FILE not readable; ignoring"
  CA_FILE=""
fi

NEED_REGISTER=0
if [[ "$MODE" == "register" ]]; then
  NEED_REGISTER=1
  API_KEY=""
elif [[ -z "$API_KEY" ]]; then
  NEED_REGISTER=1
fi

if [[ "$MODE" == "full" || "$MODE" == "cdx" ]]; then
  step "Install/update cdx wrapper -> $WRAPPER_TARGET"
  install_cdx_wrapper
  ok "cdx wrapper ready"
fi

if [[ "$MODE" == "cdx" ]]; then
  log "cdx install complete"
  exit 0
fi

if (( NEED_REGISTER )); then
  step "Registering host $FQDN at $BASE_URL"
  register_host
  ok "Registration complete"
else
  skip "Registration skipped (API key provided)"
fi

WRITE_ENV=0
if (( NEED_REGISTER )) || (( FORCE )); then
  WRITE_ENV=1
elif [[ ! -f "$ENV_PATH" ]]; then
  WRITE_ENV=1
elif [[ -n "$ENV_SOURCE_PATH" && "$ENV_SOURCE_PATH" != "$ENV_PATH" ]]; then
  WRITE_ENV=1
fi

if (( WRITE_ENV )); then
  step "Writing sync env -> $ENV_PATH"
  write_sync_env
  ok "Sync env written"
else
  skip "Sync env already present at $ENV_PATH (use --force to overwrite)"
fi

log "Done ($MODE mode)."

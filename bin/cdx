#!/usr/bin/env bash
set -euo pipefail

# Fancy-ish log strings
if [[ -t 1 ]]; then
  BOLD="\033[1m"
  DIM="\033[2m"
  GREEN="\033[32m"
  YELLOW="\033[33m"
  BLUE="\033[36m"
  RED="\033[31m"
  RESET="\033[0m"
else
  BOLD=""
  DIM=""
  GREEN=""
  YELLOW=""
  BLUE=""
  RED=""
  RESET=""
fi

log_info() { printf "%b» %s%b\n" "${BLUE}${BOLD}" "$1" "${RESET}"; }
log_warn() { printf "%b! %s%b\n" "${YELLOW}${BOLD}" "$1" "${RESET}" >&2; }
log_error() { printf "%bx %s%b\n" "${RED}${BOLD}" "$1" "${RESET}" >&2; }
log_debug() {
  (( CODEX_DEBUG )) && printf "%b[debug]%b %s\n" "${DIM}" "${RESET}" "$1" >&2
  return 0
}

mask_key() {
  local key="$1"
  if [[ -z "$key" ]]; then
    printf 'none'
    return
  fi
  local len=${#key}
  if (( len <= 8 )); then
    printf '%s' "$key"
  else
    printf '%s…%s' "${key:0:4}" "${key: -4}"
  fi
}

CODEX_DEBUG=${CODEX_DEBUG:-0}

# Default sync API endpoint; can be overridden via env or config files.
CODEX_SYNC_BASE_URL_DEFAULT="https://codex-auth.uggs.io"
CODEX_SYNC_BASE_URL="${CODEX_SYNC_BASE_URL:-$CODEX_SYNC_BASE_URL_DEFAULT}"
CODEX_SYNC_API_KEY="${CODEX_SYNC_API_KEY:-}"
CODEX_SYNC_FQDN="${CODEX_SYNC_FQDN:-}"
CODEX_SYNC_CA_FILE="${CODEX_SYNC_CA_FILE:-}"
CODEX_SYNC_CONFIG_PATHS=()
if [[ -n "${CODEX_SYNC_CONFIG_PATH:-}" ]]; then
  CODEX_SYNC_CONFIG_PATHS+=("$CODEX_SYNC_CONFIG_PATH")
else
  CODEX_SYNC_CONFIG_PATHS+=("/etc/codex-sync.env" "/usr/local/etc/codex-sync.env" "$HOME/.codex/sync.env")
fi
SYNC_CONFIG_LOADED=0
SYNC_WARNED_NO_PYTHON=0
CODEX_COMMAND_STARTED=0
SYNC_PUSH_COMPLETED=0
ORIGINAL_LAST_REFRESH=""
AUTH_PUSH_RESULT=""
AUTH_PUSH_REASON=""
AUTH_STATUS=""
AUTH_ACTION=""
AUTH_MESSAGE=""
SYNC_REMOTE_CLIENT_VERSION=""
SYNC_REMOTE_WRAPPER_VERSION=""
SYNC_REMOTE_WRAPPER_SHA256=""
SYNC_REMOTE_WRAPPER_URL=""
AUTH_PULL_STATUS="skip"
AUTH_PULL_URL=""

WRAPPER_VERSION="2025.11.22-6"

IS_ROOT=0
CAN_SUDO=0
SUDO_BIN="sudo -n"
if (( EUID == 0 )); then
  IS_ROOT=1
elif command -v sudo >/dev/null 2>&1; then
  if sudo -n true >/dev/null 2>&1; then
    CAN_SUDO=1
  fi
fi

CURRENT_USER="$(id -un 2>/dev/null || echo unknown)"
# Expose wrapper version quickly
if [[ "${1-}" == "--wrapper-version" || "${1-}" == "-W" ]]; then
  printf 'cdx wrapper %s\n' "$WRAPPER_VERSION"
  exit 0
fi

case "${1-}" in
  --debug|--verbose)
    CODEX_DEBUG=1
    shift
    ;;
esac

if (( ! IS_ROOT )); then
  # Only auto-install when we can sudo and we're the expected user (chris)
  if (( CAN_SUDO == 0 )) || [[ "$CURRENT_USER" != "chris" ]]; then
    log_info "Non-root execution detected; skipping automatic Codex install/update."
  fi
fi
log_debug "starting | user=${CURRENT_USER} | can_manage=${CAN_SUDO} | path=$PATH"

detect_linux_package_manager() {
  local tokens=()
  if [[ -r /etc/os-release ]]; then
    # shellcheck disable=SC1091
    . /etc/os-release
    if [[ -n "${ID:-}" ]]; then
      tokens+=("$ID")
    fi
    if [[ -n "${ID_LIKE:-}" ]]; then
      local like
      for like in $ID_LIKE; do
        tokens+=("$like")
      done
    fi
  fi
  local token
  for token in "${tokens[@]}"; do
    case "$token" in
      debian|ubuntu)
        if command -v apt-get >/dev/null 2>&1; then
          printf '%s' apt-get
          return 0
        fi
        ;;
      rhel|centos|fedora|almalinux|rocky|ol)
        if command -v dnf >/dev/null 2>&1; then
          printf '%s' dnf
          return 0
        fi
        ;;
    esac
  done
  if command -v apt-get >/dev/null 2>&1; then
    printf '%s' apt-get
    return 0
  fi
  if command -v dnf >/dev/null 2>&1; then
    printf '%s' dnf
    return 0
  fi
  return 1
}

ensure_commands() {
  local missing=()
  local cmd
  for cmd in "$@"; do
    if ! command -v "$cmd" >/dev/null 2>&1; then
      missing+=("$cmd")
    fi
  done

  if (( ${#missing[@]} == 0 )); then
    return 0
  fi

  if [[ "$(uname -s)" != "Linux" ]]; then
    log_error "Missing required commands: ${missing[*]}. Automatic installation is only supported on Linux."
    exit 1
  fi

  local pm=""
  if ! pm="$(detect_linux_package_manager)"; then
    log_error "Missing required commands: ${missing[*]}. Unable to determine package manager for automatic installation."
    exit 1
  fi

  local use_sudo=()
  if (( EUID != 0 )); then
    if command -v sudo >/dev/null 2>&1; then
      use_sudo=(sudo)
    else
      log_error "Missing required commands: ${missing[*]}. Install them manually or rerun Codex as root to allow automatic installation."
      exit 1
    fi
  fi

  case "$pm" in
    apt-get)
      log_info "Installing prerequisites (${missing[*]}) with apt-get"
      if (( ${#use_sudo[@]} > 0 )); then
        "${use_sudo[@]}" apt-get update -qq
        "${use_sudo[@]}" env DEBIAN_FRONTEND=noninteractive apt-get install -y --no-install-recommends "${missing[@]}"
      else
        apt-get update -qq
        DEBIAN_FRONTEND=noninteractive apt-get install -y --no-install-recommends "${missing[@]}"
      fi
      ;;
    dnf)
      log_info "Installing prerequisites (${missing[*]}) with dnf"
      if (( ${#use_sudo[@]} > 0 )); then
        "${use_sudo[@]}" dnf install -y "${missing[@]}"
      else
        dnf install -y "${missing[@]}"
      fi
      ;;
    *)
      log_error "Unsupported package manager: ${pm}"
      exit 1
      ;;
  esac

  local still_missing=()
  for cmd in "${missing[@]}"; do
    if ! command -v "$cmd" >/dev/null 2>&1; then
      still_missing+=("$cmd")
    fi
  done

  if (( ${#still_missing[@]} > 0 )); then
    log_error "Failed to install required commands: ${still_missing[*]}"
    exit 1
  fi
}

is_codex_installed_via_npm() {
  if ! command -v npm >/dev/null 2>&1; then
    return 1
  fi
  if npm list -g codex-cli --depth=0 >/dev/null 2>&1; then
    return 0
  fi
  return 1
}

update_codex_via_npm() {
  local target="$1"
  if ! command -v npm >/dev/null 2>&1; then
    return 1
  fi
  if [[ -z "$target" ]]; then
    npm install -g codex-cli >/dev/null
  else
    npm install -g "codex-cli@$target" >/dev/null
  fi
}

real_path() {
  if command -v realpath >/dev/null 2>&1; then
    realpath "$1"
  elif command -v python3 >/dev/null 2>&1; then
    python3 - "$1" <<'PY'
import os, sys
print(os.path.realpath(sys.argv[1]))
PY
  else
    # best effort fallback
    local dir
    dir="$(cd "$(dirname "$1")" 2>/dev/null && pwd)"
    printf '%s/%s\n' "${dir:-.}" "$(basename "$1")"
  fi
}

get_file_mtime() {
  if stat --version >/dev/null 2>&1; then
    stat -c %Y "$1"
  else
    stat -f %m "$1"
  fi
}

resolve_real_codex() {
  local self_real
  self_real="$(real_path "$0")"
  local prefer_paths=(
    /usr/local/bin/codex
    /opt/codex/bin/codex
  )
  local preferred=""
  for preferred in "${prefer_paths[@]}"; do
    if [[ -x "$preferred" ]]; then
      local preferred_real
      preferred_real="$(real_path "$preferred")"
      if [[ "$preferred_real" != "$self_real" ]]; then
        printf '%s' "$preferred_real"
        return 0
      fi
    fi
  done
  local found=""
  IFS=: read -r -a path_entries <<< "${PATH:-}"
  for entry in "${path_entries[@]}"; do
    [[ -z "$entry" ]] && entry="."
    local candidate="$entry/codex"
    [[ ! -x "$candidate" ]] && continue
    local candidate_real
    candidate_real="$(real_path "$candidate")"
    if [[ "$candidate_real" == "$self_real" ]]; then
      continue
    fi
    found="$candidate_real"
    break
  done
  if [[ -z "$found" && -x /usr/local/bin/codex ]]; then
    found="$(real_path /usr/local/bin/codex)"
  fi
  printf '%s' "$found"
}

normalize_version() {
  local v="$1"
  v="${v#codex-cli }"
  v="${v#codex }"
  v="${v#rust-}"
  v="${v#v}"
  printf '%s' "$v"
}

detect_glibc_version() {
  local version=""
  if command -v getconf >/dev/null 2>&1; then
    local gc
    gc="$(getconf GNU_LIBC_VERSION 2>/dev/null || true)"
    if [[ "$gc" =~ ([0-9]+\.[0-9]+) ]]; then
      version="${BASH_REMATCH[1]}"
    fi
  fi
  if [[ -z "$version" ]]; then
    if command -v ldd >/dev/null 2>&1; then
      local first
      first="$(ldd --version 2>&1 | head -n1)"
      if [[ "$first" =~ ([0-9]+\.[0-9]+) ]]; then
        version="${BASH_REMATCH[1]}"
      fi
    fi
  fi
  printf '%s' "$version"
}

version_lt() {
  local a="$1"
  local b="$2"
  [[ "$a" == "$b" ]] && return 1
  if [[ "$(printf '%s\n%s\n' "$a" "$b" | sort -V | head -n1)" == "$a" ]]; then
    return 0
  fi
  return 1
}

probe_latest_version_tag() {
  local url="${1:-https://github.com/openai/codex/releases/latest}"
  if ! command -v curl >/dev/null 2>&1; then
    return 1
  fi
  local effective
  if ! effective="$(curl -fsSLI -o /dev/null -w '%{url_effective}' -L "$url" 2>/dev/null)"; then
    return 1
  fi
  if [[ "$effective" =~ /tag/([^/]+)$ ]]; then
    printf '%s' "${BASH_REMATCH[1]}"
    return 0
  fi
  return 1
}

require_python() {
  if ! command -v python3 >/dev/null 2>&1; then
    log_warn "python3 is required for update checks; skipping update detection."
    return 1
  fi
  return 0
}

parse_sync_env_file() {
  local path="$1"
  local key value
  while IFS='=' read -r key value; do
    value="${value%$'\r'}"
    case "$key" in
      ''|\#*) continue ;;
    esac
    case "$key" in
      CODEX_SYNC_BASE_URL)
        CODEX_SYNC_BASE_URL="${value%/}"
        ;;
      CODEX_SYNC_API_KEY)
        CODEX_SYNC_API_KEY="$value"
        ;;
      CODEX_SYNC_FQDN)
        CODEX_SYNC_FQDN="$value"
        ;;
      CODEX_SYNC_CA_FILE)
        CODEX_SYNC_CA_FILE="$value"
        ;;
    esac
  done <"$path"
}

load_sync_config() {
  if (( SYNC_CONFIG_LOADED )); then
    return 0
  fi
  local path=""
  for path in "${CODEX_SYNC_CONFIG_PATHS[@]}"; do
    [[ -z "$path" ]] && continue
    if [[ -f "$path" ]]; then
      parse_sync_env_file "$path"
      log_debug "loaded sync env: $path"
    fi
  done
  if [[ -z "$CODEX_SYNC_BASE_URL" ]]; then
    CODEX_SYNC_BASE_URL="$CODEX_SYNC_BASE_URL_DEFAULT"
  fi
  log_debug "config | base=${CODEX_SYNC_BASE_URL} | api_key=$(mask_key "$CODEX_SYNC_API_KEY") | fqdn=${CODEX_SYNC_FQDN:-none} | ca=${CODEX_SYNC_CA_FILE:-none}"
  SYNC_CONFIG_LOADED=1
}

sync_auth_with_api() {
  local phase="$1"
  load_sync_config
  if [[ -z "$CODEX_SYNC_API_KEY" || -z "$CODEX_SYNC_BASE_URL" ]]; then
    log_error "Sync config missing API key or base URL; create ~/.codex/sync.env or set CODEX_SYNC_*"
    AUTH_PULL_STATUS="missing-config"
    AUTH_PULL_URL="$CODEX_SYNC_BASE_URL"
    return 1
  fi
  if ! command -v python3 >/dev/null 2>&1; then
    if (( SYNC_WARNED_NO_PYTHON == 0 )); then
      log_warn "python3 is required for Codex auth sync; skipping API synchronization."
      SYNC_WARNED_NO_PYTHON=1
    fi
    return 1
  fi
  local auth_path="$HOME/.codex/auth.json"
   # Drop a malformed local auth.json so we can hydrate cleanly.
  if [[ -f "$auth_path" ]] && ! validate_auth_json_file "$auth_path"; then
    rm -f "$auth_path"
  fi
  local phase_label
  phase_label="${phase:-sync}"
  # No chatty per-step auth logging; final summary will capture the outcome.
  local api_output=""
  local api_status=0
  if api_output="$(python3 - "$CODEX_SYNC_BASE_URL" "$CODEX_SYNC_API_KEY" "$auth_path" "$CODEX_SYNC_CA_FILE" "$LOCAL_VERSION" "$WRAPPER_VERSION" <<'PY'
import hashlib, json, os, pathlib, ssl, sys, urllib.error, urllib.request

base = (sys.argv[1] or "").rstrip("/")
api_key = sys.argv[2]
path = pathlib.Path(sys.argv[3]).expanduser()
cafile = sys.argv[4] if len(sys.argv) > 4 else ""
client_version = sys.argv[5] if len(sys.argv) > 5 else "unknown"
wrapper_version = sys.argv[6] if len(sys.argv) > 6 else "unknown"

if not base:
    print("Sync API base URL missing", file=sys.stderr)
    sys.exit(1)


def default_auth():
    return {"last_refresh": "2000-01-01T00:00:00Z", "auths": {}}


def load_auth():
    try:
        data = json.loads(path.read_text(encoding="utf-8"))
    except Exception:  # noqa: BLE001
        return default_auth()
    if not isinstance(data, dict) or "last_refresh" not in data:
        return default_auth()
    return data


def canonical_json(obj):
    return json.dumps(obj, ensure_ascii=False, separators=(",", ":"))


def build_context():
    contexts = []
    # Preferred: custom CA if provided
    ctx_primary = ssl.create_default_context()
    if cafile:
        try:
            ctx_primary.load_verify_locations(cafile)
        except Exception:
            ctx_primary = None
    if ctx_primary is not None:
        try:
            ctx_primary.verify_flags &= ~ssl.VERIFY_X509_STRICT
        except AttributeError:
            pass
        contexts.append(ctx_primary)
    # Fallback: system default
    try:
        ctx_default = ssl.create_default_context()
        ctx_default.verify_flags &= ~ssl.VERIFY_X509_STRICT
        contexts.append(ctx_default)
    except Exception:
        pass
    # Last resort: unverified (only if others fail)
    try:
        contexts.append(ssl._create_unverified_context())
    except Exception:
        pass
    return contexts or [None]


def parse_error_body(body: str):
    msg = body
    details = {}
    try:
        parsed = json.loads(body)
        if isinstance(parsed, dict):
            msg = parsed.get("message", body)
            details = parsed.get("details", {}) or {}
    except Exception:
        pass
    return msg, details


def fail_with_http(exc: urllib.error.HTTPError, action: str):
    body = exc.read().decode("utf-8", "ignore")
    msg, details = parse_error_body(body)
    expected_ip = details.get("expected_ip") if isinstance(details, dict) else None
    received_ip = details.get("received_ip") if isinstance(details, dict) else None
    extra = ""
    if expected_ip or received_ip:
        parts = []
        if expected_ip:
            parts.append(f"expected {expected_ip}")
        if received_ip:
            parts.append(f"received {received_ip}")
        extra = " (" + ", ".join(parts) + ")"
    if exc.code == 401:
        if "Invalid API key" in msg:
            sys.exit(10)
        if "API key missing" in msg:
            sys.exit(21)
        sys.exit(22)
    if exc.code == 403:
        if "Host is disabled" in msg:
            sys.exit(11)
        if "not allowed from this IP" in msg or expected_ip or received_ip:
            print(f"{action} denied (IP bound){extra}", file=sys.stderr)
            sys.exit(12)
        sys.exit(23)
    if exc.code == 503 and "disabled" in msg.lower():
        print("api disabled", file=sys.stderr)
        sys.exit(40)
    print(f"{action} failed ({exc.code}): {msg}{extra}", file=sys.stderr)
    sys.exit(2)


def post_json(url: str, payload: dict, action: str):
    body = canonical_json(payload).encode("utf-8")
    headers = {"Content-Type": "application/json", "X-API-Key": api_key}
    req = urllib.request.Request(url, data=body, headers=headers, method="POST")
    contexts = build_context()
    last_err = None
    for ctx in contexts:
        try:
            with urllib.request.urlopen(req, timeout=20, context=ctx) as resp:
                return json.load(resp)
        except urllib.error.HTTPError as exc:
            fail_with_http(exc, action)
        except Exception as exc:  # noqa: BLE001
            last_err = exc
            continue
    print(f"{action} failed: {last_err}", file=sys.stderr)
    sys.exit(3)


current = load_auth()
auth_json = canonical_json(current)
auth_sha = hashlib.sha256(auth_json.encode("utf-8")).hexdigest()

retrieve_payload = {
    "command": "retrieve",
    "last_refresh": current.get("last_refresh") or "2000-01-01T00:00:00Z",
    "digest": auth_sha,
    "client_version": client_version or "unknown",
}
if wrapper_version and wrapper_version != "unknown":
    retrieve_payload["wrapper_version"] = wrapper_version

retrieve_data = post_json(f"{base}/auth", retrieve_payload, "auth retrieve")
payload_data = retrieve_data.get("data") if isinstance(retrieve_data, dict) else {}
status = (payload_data or {}).get("status")
versions_block = payload_data.get("versions") if isinstance(payload_data, dict) else {}
canonical_digest = payload_data.get("canonical_digest") or payload_data.get("digest")
auth_to_write = None


def record_versions(vblock):
    out = {}
    if isinstance(vblock, dict):
        cv = vblock.get("client_version")
        if isinstance(cv, str) and cv.strip():
            out["client_version"] = cv.strip()
        wv = vblock.get("wrapper_version")
        if isinstance(wv, str) and wv.strip():
            out["wrapper_version"] = wv.strip()
        ws = vblock.get("wrapper_sha256")
        if isinstance(ws, str) and ws.strip():
            out["wrapper_sha256"] = ws.strip()
        wu = vblock.get("wrapper_url")
        if isinstance(wu, str) and wu.strip():
            out["wrapper_url"] = wu.strip()
    return out


versions_out = record_versions(versions_block)
if versions_out.get("client_version"):
    SYNC_REMOTE_CLIENT_VERSION = versions_out.get("client_version")
if versions_out.get("wrapper_version"):
    SYNC_REMOTE_WRAPPER_VERSION = versions_out.get("wrapper_version")
if versions_out.get("wrapper_sha256"):
    SYNC_REMOTE_WRAPPER_SHA256 = versions_out.get("wrapper_sha256")
if versions_out.get("wrapper_url"):
    SYNC_REMOTE_WRAPPER_URL = versions_out.get("wrapper_url")

if status == "valid":
    auth_to_write = current
elif status == "outdated":
    auth_to_write = payload_data.get("auth") or current
    lr = payload_data.get("canonical_last_refresh") or payload_data.get("last_refresh")
    if isinstance(lr, str):
        auth_to_write["last_refresh"] = lr
elif status in ("missing", "upload_required"):
    pass
else:
    status = "upload_required"

if status in ("missing", "upload_required"):
    store_payload = {
        "command": "store",
        "auth": current,
        "client_version": client_version or "unknown",
    }
    if canonical_digest:
        store_payload["digest"] = canonical_digest
    if wrapper_version and wrapper_version != "unknown":
        store_payload["wrapper_version"] = wrapper_version
    update_data = post_json(f"{base}/auth", store_payload, "auth store")
    payload_data = update_data.get("data") if isinstance(update_data, dict) else {}
    versions_out = record_versions(payload_data.get("versions", {})) or versions_out
    auth_to_write = payload_data.get("auth") or current
    lr = payload_data.get("canonical_last_refresh") or payload_data.get("last_refresh")
    if isinstance(lr, str):
        auth_to_write["last_refresh"] = lr

if not isinstance(auth_to_write, dict):
    auth_to_write = current

path.parent.mkdir(parents=True, exist_ok=True)
path.write_text(json.dumps(auth_to_write, indent=2) + "\n", encoding="utf-8")
try:
    os.chmod(path, 0o600)
except PermissionError:
    pass

# Surface versions and auth outcome to caller via stdout as JSON
print(
    json.dumps(
        {
            "versions": versions_out,
            "auth_status": status or "unknown",
            "auth_action": ("store" if status in ("missing", "upload_required") else status or "unknown"),
            "auth_message": (
                "synced (no change)" if status == "valid" else
                "updated from api" if status == "outdated" else
                "uploaded current auth" if status in ("missing", "upload_required") else
                status
            ),
        },
        separators=(",", ":"),
    )
)
PY
  )"; then
    log_debug "auth api output: ${api_output}"
    local versions_json
    versions_json="$api_output"
    if [[ -n "$versions_json" ]] && command -v python3 >/dev/null 2>&1; then
      local parsed
      parsed="$(VJSON="$versions_json" python3 - <<'PY'
import json, os, sys
data = os.environ.get("VJSON", "")
try:
    parsed = json.loads(data)
except Exception:
    sys.exit(0)
if not isinstance(parsed, dict):
    sys.exit(0)
versions = parsed.get("versions")
if not isinstance(versions, dict):
    sys.exit(0)
cv = versions.get("client_version")
wv = versions.get("wrapper_version")
ws = versions.get("wrapper_sha256")
wu = versions.get("wrapper_url")
if isinstance(cv, str) and cv.strip():
    print(f"cv={cv.strip()}")
if isinstance(wv, str) and wv.strip():
    print(f"wv={wv.strip()}")
if isinstance(ws, str) and ws.strip():
    print(f"ws={ws.strip()}")
if isinstance(wu, str) and wu.strip():
    print(f"wu={wu.strip()}")
asv = parsed.get("auth_status")
if isinstance(asv, str) and asv.strip():
    print(f"as={asv.strip()}")
aact = parsed.get("auth_action")
if isinstance(aact, str) and aact.strip():
    print(f"aa={aact.strip()}")
amsg = parsed.get("auth_message")
if isinstance(amsg, str) and amsg.strip():
    print(f"am={amsg.strip()}")
PY
)" || true
      if [[ -n "$parsed" ]]; then
        local line
        while IFS= read -r line; do
          case "$line" in
            cv=*)
              SYNC_REMOTE_CLIENT_VERSION="${line#cv=}"
              ;;
            wv=*)
              SYNC_REMOTE_WRAPPER_VERSION="${line#wv=}"
              ;;
            ws=*)
              SYNC_REMOTE_WRAPPER_SHA256="${line#ws=}"
              ;;
            wu=*)
              SYNC_REMOTE_WRAPPER_URL="${line#wu=}"
              ;;
            as=*)
              AUTH_STATUS="${line#as=}"
              ;;
            aa=*)
              AUTH_ACTION="${line#aa=}"
              ;;
            am=*)
              AUTH_MESSAGE="${line#am=}"
              ;;
          esac
        done <<<"$parsed"
      fi
    fi
    AUTH_PULL_STATUS="ok"
    AUTH_PULL_URL="$CODEX_SYNC_BASE_URL"
    return 0
  else
    api_status=$?
  fi
  case "$api_status" in
    10)
      log_warn "Auth sync denied: invalid API key; removing local auth.json"
      AUTH_PULL_STATUS="invalid"
      rm -f "$auth_path" 2>/dev/null || true
      return 1
      ;;
    11)
      log_warn "Auth sync denied: host disabled; removing local auth.json"
      rm -f "$auth_path" 2>/dev/null || true
      return 1
      ;;
    12)
      log_warn "Auth sync blocked for this IP (key bound elsewhere); re-register to rotate the key. Keeping local auth.json."
      return 1
      ;;
    21|22)
      log_warn "Auth sync failed: API key missing/invalid"
      return 1
      ;;
    40)
      log_warn "Auth sync blocked: API disabled by administrator"
      AUTH_PULL_STATUS="disabled"
      AUTH_PULL_URL="$CODEX_SYNC_BASE_URL"
      return 1
      ;;
    *)
      if [[ -n "$phase" ]]; then
        log_warn "Auth API sync (${phase}) failed (base=${CODEX_SYNC_BASE_URL}, key=$(mask_key "$CODEX_SYNC_API_KEY"))"
      else
        log_warn "Auth API sync failed (base=${CODEX_SYNC_BASE_URL}, key=$(mask_key "$CODEX_SYNC_API_KEY"))"
      fi
      rm -f "$auth_path" 2>/dev/null || true
      AUTH_PULL_STATUS="fail"
      AUTH_PULL_URL="$CODEX_SYNC_BASE_URL"
      return 1
      ;;
  esac
  return 1
}

get_auth_last_refresh() {
  local path="$1"
  if [[ ! -f "$path" ]]; then
    return 0
  fi
  if ! command -v python3 >/dev/null 2>&1; then
    return 0
  fi
  python3 - "$path" <<'PY'
import json, sys, pathlib
path = pathlib.Path(sys.argv[1])
try:
    data = json.loads(path.read_text(encoding="utf-8"))
except Exception:  # noqa: BLE001
    sys.exit(0)
if isinstance(data, dict):
    lr = data.get("last_refresh")
    if isinstance(lr, str):
        print(lr, end="")
PY
}

validate_auth_json_file() {
  local path="$1"
  if [[ ! -f "$path" ]]; then
    return 1
  fi
  if ! command -v python3 >/dev/null 2>&1; then
    return 1
  fi
  python3 - "$path" <<'PY'
import json, sys, pathlib

path = pathlib.Path(sys.argv[1])
try:
    data = json.loads(path.read_text(encoding="utf-8"))
except Exception:  # noqa: BLE001
    sys.exit(1)

if not isinstance(data, dict):
    sys.exit(1)

last_refresh = data.get("last_refresh")
auths = data.get("auths")

if not isinstance(last_refresh, str) or not last_refresh.strip():
    sys.exit(1)

if not isinstance(auths, dict) or not auths:
    sys.exit(1)

for target, entry in auths.items():
    if not isinstance(target, str) or not target.strip():
        sys.exit(1)
    if not isinstance(entry, dict):
        sys.exit(1)
    token = entry.get("token")
    if not isinstance(token, str) or not token.strip():
        sys.exit(1)

sys.exit(0)
PY
}

push_auth_if_changed() {
  local phase="${1:-push}"
  local auth_path="$HOME/.codex/auth.json"
  local refreshed
  refreshed="$(get_auth_last_refresh "$auth_path")"
  # No local auth present
  if [[ -z "$ORIGINAL_LAST_REFRESH" && -z "$refreshed" ]]; then
    AUTH_PUSH_RESULT="skipped"
    AUTH_PUSH_REASON="no local auth.json"
    return 0
  fi
  if [[ "$refreshed" == "$ORIGINAL_LAST_REFRESH" ]]; then
    AUTH_PUSH_RESULT="not-needed"
    AUTH_PUSH_REASON="auth.json unchanged"
    return 0
  fi
  if sync_auth_with_api "$phase"; then
    SYNC_PUSH_COMPLETED=1
    AUTH_PUSH_RESULT="uploaded"
    AUTH_PUSH_REASON="auth.json changed"
    return 0
  fi
  AUTH_PUSH_RESULT="failed"
  AUTH_PUSH_REASON="api sync error"
  return 1
}

extract_token_usage_payload() {
  local log_path="$1"
  if [[ ! -f "$log_path" ]]; then
    return 0
  fi
  if ! command -v python3 >/dev/null 2>&1; then
    return 0
  fi
  python3 - "$log_path" <<'PY'
import json, pathlib, re, sys

path = pathlib.Path(sys.argv[1])
try:
    content = path.read_text(encoding="utf-8", errors="ignore")
except Exception:  # noqa: BLE001
    sys.exit(0)

lines = [ln.strip() for ln in content.splitlines() if "Token usage" in ln]
if not lines:
    sys.exit(0)

line = lines[-1]
pattern = re.compile(
    r"Token usage:\s*total=([\d,]+)\s+input=([\d,]+)(?:\s*\(\+\s*([\d,]+)\s*cached\))?\s+output=([\d,]+)",
    re.IGNORECASE,
)
data = {"line": line}
match = pattern.search(line)
if match:
    def clean(val: str | None):
        return int(val.replace(",", "")) if val else None

    data["total"] = clean(match.group(1))
    data["input"] = clean(match.group(2))
    data["output"] = clean(match.group(4))
    cached = clean(match.group(3))
    if cached is not None:
        data["cached"] = cached

print(json.dumps(data, separators=(",", ":")))
PY
}

post_token_usage_payload() {
  local payload_json="$1"
  if [[ -z "$payload_json" ]]; then
    return 0
  fi
  if [[ -z "$CODEX_SYNC_API_KEY" || -z "$CODEX_SYNC_BASE_URL" ]]; then
    log_warn "Usage push skipped: API key or base URL missing"
    return 1
  fi
  if ! command -v python3 >/dev/null 2>&1; then
    log_warn "Usage push skipped: python3 missing"
    return 1
  fi

  local summary
  if summary="$(python3 - "$CODEX_SYNC_BASE_URL" "$CODEX_SYNC_API_KEY" "$payload_json" "$CODEX_SYNC_CA_FILE" <<'PY'
import json, ssl, sys, urllib.error, urllib.request

base = (sys.argv[1] or "").rstrip("/")
api_key = sys.argv[2]
payload_raw = sys.argv[3]
cafile = sys.argv[4] if len(sys.argv) > 4 else ""

try:
    payload = json.loads(payload_raw)
except Exception:  # noqa: BLE001
    sys.exit(1)

body = json.dumps(payload, separators=(",", ":")).encode("utf-8")
headers = {"Content-Type": "application/json", "X-API-Key": api_key}
url = f"{base}/usage"
req = urllib.request.Request(url, data=body, headers=headers, method="POST")


def build_contexts():
    contexts = []
    try:
        ctx = ssl.create_default_context()
        if cafile:
            ctx.load_verify_locations(cafile)
        try:
            ctx.verify_flags &= ~ssl.VERIFY_X509_STRICT
        except Exception:
            pass
        contexts.append(ctx)
    except Exception:
        pass
    try:
        contexts.append(ssl._create_unverified_context())
    except Exception:
        pass
    return contexts or [None]


def format_summary(data: dict) -> str:
    parts = []
    for key in ("total", "input", "output", "cached"):
        if key in data and data[key] is not None:
            parts.append(f"{key}={data[key]}")
    if not parts and data.get("line"):
        return data["line"]
    return " ".join(parts)


last_err = None
for ctx in build_contexts():
    try:
        with urllib.request.urlopen(req, timeout=10, context=ctx) as resp:  # noqa: S310
            resp.read(512)
            print(format_summary(payload))
            sys.exit(0)
    except urllib.error.HTTPError as exc:
        last_err = f"HTTP {exc.code}"
        continue
    except Exception as exc:  # noqa: BLE001
        last_err = str(exc)
        continue

if last_err:
    print(last_err, file=sys.stderr)
sys.exit(1)
PY
  )"; then
    log_info "Usage push | ok | ${summary}"
    return 0
  fi

  log_warn "Usage push | failed"
  return 1
}

send_token_usage_if_present() {
  local log_path="$1"
  local payload
  payload="$(extract_token_usage_payload "$log_path")" || return 0
  if [[ -z "$payload" ]]; then
    return 0
  fi

  post_token_usage_payload "$payload" || true
}

fetch_release_payload() {
  local api_url="$1"
  local wanted_asset="$2"
  python3 - "$api_url" "$wanted_asset" <<'PY'
import json, sys, time, urllib.request
url = sys.argv[1]
wanted = sys.argv[2]
headers = {
    "Accept": "application/vnd.github+json",
    "User-Agent": "codex-wrapper-update-check"
}
try:
    req = urllib.request.Request(url, headers=headers)
    with urllib.request.urlopen(req, timeout=15) as resp:
        data = json.load(resp)
except Exception as exc:  # noqa: BLE001
    print(f"error: {exc}", file=sys.stderr)
    sys.exit(1)
name = data.get("name") or data.get("tag_name") or ""
assets = data.get("assets") or []
asset = None
if wanted:
    for candidate in assets:
        if candidate.get("name") == wanted:
            asset = candidate
            break
if asset is None:
    for candidate in assets:
        if candidate.get("name") == "codex":
            asset = candidate
            break
if asset is None:
    print("error: could not find a matching release asset", file=sys.stderr)
    sys.exit(2)
payload = {
    "timestamp": int(time.time()),
    "version": name,
    "tag": data.get("tag_name") or "",
    "asset_name": asset.get("name", ""),
    "download_url": asset.get("browser_download_url", "")
}
json.dump(payload, sys.stdout, separators=(",", ":"))
PY
}

read_cached_payload() {
  local cache_file="$1"
  python3 - "$cache_file" <<'PY'
import json, sys
with open(sys.argv[1], 'r', encoding='utf-8') as fh:
    data = json.load(fh)
print(data.get('version', ''))
print(data.get('download_url', ''))
print(data.get('asset_name', ''))
print(data.get('timestamp', 0))
print(data.get('tag', ''))
PY
}

perform_update() (
  set -euo pipefail
  local target_path="$1"
  local url="$2"
  local asset_name="$3"
  local new_version="$4"
  local tmpdir
  tmpdir="$(mktemp -d)"
  trap 'rm -rf "$tmpdir"' EXIT
  log_info "Downloading Codex ${new_version}"
  local asset_file="$tmpdir/asset"
  if ! curl -fsSL "$url" -o "$asset_file"; then
    log_error "Download failed from $url"
    exit 1
  fi
  local extracted="$asset_file"
  case "$asset_name" in
    *.tar.gz)
      tar -xzf "$asset_file" -C "$tmpdir"
      # pick the first executable named codex*
      extracted="$(find "$tmpdir" -type f -name 'codex*' ! -name 'asset' | head -n1)"
      ;;
    *.zip)
      if ! command -v unzip >/dev/null 2>&1; then
        log_error "unzip is required to handle $asset_name"
        exit 1
      fi
      unzip -q "$asset_file" -d "$tmpdir"
      extracted="$(find "$tmpdir" -type f -name 'codex*' | head -n1)"
      ;;
  esac
  if [[ -z "$extracted" || ! -f "$extracted" ]]; then
    log_error "Unable to locate Codex binary inside downloaded asset"
    exit 1
  fi
  chmod +x "$extracted"
  local target_dir
  target_dir="$(dirname "$target_path")"
  if [[ ! -d "$target_dir" ]]; then
    log_error "Target directory $target_dir does not exist"
    exit 1
  fi
  if [[ -w "$target_dir" ]]; then
    log_info "Installing Codex into $target_path"
    install -m 755 "$extracted" "$target_path"
  else
    if (( CAN_SUDO )); then
      log_info "Installing Codex into $target_path with sudo -n"
      $SUDO_BIN install -m 755 "$extracted" "$target_path"
    else
      log_warn "Insufficient permissions to install Codex into $target_path (no sudo)."
      exit 1
    fi
  fi
  log_info "Codex updated to ${new_version}"
)

API_RELEASES_URL="https://api.github.com/repos/openai/codex/releases"

SCRIPT_REAL="$(real_path "$0")"
CODEX_REAL_BIN="$(resolve_real_codex)"
if [[ -z "$CODEX_REAL_BIN" ]]; then
  log_error "Unable to find the real Codex binary on PATH"
  exit 1
fi

platform_os="$(uname -s 2>/dev/null || echo unknown)"
platform_arch="$(uname -m 2>/dev/null || echo unknown)"
log_info "cdx ${WRAPPER_VERSION} | user ${CURRENT_USER} | ${platform_os}/${platform_arch}"

can_manage_codex=0
if (( IS_ROOT )); then
  can_manage_codex=1
elif (( CAN_SUDO )) && [[ "$CURRENT_USER" == "chris" ]]; then
  can_manage_codex=1
fi

if (( can_manage_codex )) && [[ "$(uname -s)" == "Linux" ]]; then
  ensure_commands curl unzip
fi

LOCAL_VERSION_RAW="$("$CODEX_REAL_BIN" -V 2>/dev/null || true)"
LOCAL_VERSION="$(normalize_version "$LOCAL_VERSION_RAW")"
LOCAL_VERSION_UNKNOWN=0
if [[ -z "$LOCAL_VERSION" ]]; then
  LOCAL_VERSION_UNKNOWN=1
  log_warn "Could not determine local Codex version; attempting to refresh Codex before launch."
fi

# Early auth + versions sync (single POST), captures target versions and hydrates auth if needed.
sync_auth_with_api "pull" || true
ORIGINAL_LAST_REFRESH="$(get_auth_last_refresh "$HOME/.codex/auth.json")"

os_name="$(uname -s)"
arch_name="$(uname -m)"
asset_name=""
skip_update_check=0
if (( ! can_manage_codex )); then
  skip_update_check=1
fi
case "$os_name" in
  Linux)
    case "$arch_name" in
      x86_64|amd64)
        asset_name="codex-x86_64-unknown-linux-gnu.tar.gz"
        glibc_version="$(detect_glibc_version)"
        if [[ -z "$glibc_version" ]]; then
          asset_name="codex-x86_64-unknown-linux-musl.tar.gz"
          log_info "Unable to detect glibc version; using musl Codex build for compatibility."
        elif version_lt "$glibc_version" "2.39"; then
          asset_name="codex-x86_64-unknown-linux-musl.tar.gz"
          log_info "glibc ${glibc_version} detected; using musl Codex build for compatibility."
        fi
        ;;
      aarch64|arm64)
        asset_name="codex-aarch64-unknown-linux-gnu.tar.gz"
        ;;
      *)
        log_warn "Unsupported Linux architecture (${arch_name}); skipping update check."
        skip_update_check=1
        ;;
    esac
    ;;
  *)
    log_warn "Non-Linux operating system (${os_name}) detected; skipping update check."
    skip_update_check=1
    ;;
esac

remote_version=""
remote_url=""
remote_asset=""
remote_tag=""
remote_source=""
remote_timestamp=0
prefer_npm_update=0

if (( ! skip_update_check )); then
  if [[ "$AUTH_PULL_STATUS" == "ok" && -n "$SYNC_REMOTE_CLIENT_VERSION" ]]; then
    remote_version="$(normalize_version "$SYNC_REMOTE_CLIENT_VERSION")"
    remote_tag="$remote_version"
    remote_timestamp="$(date +%s)"
    remote_source="api"
  elif [[ "$AUTH_PULL_STATUS" == "ok" ]]; then
    # API succeeded but no version provided; assume local is target to avoid noisy warnings.
    remote_version="$LOCAL_VERSION"
    remote_tag="$LOCAL_VERSION"
    remote_source="api"
  fi
fi

need_update=0
norm_remote=""
if (( ! skip_update_check )) && [[ -n "$remote_version" ]]; then
  norm_remote="$(normalize_version "$remote_version")"
  if (( LOCAL_VERSION_UNKNOWN )); then
    need_update=1
  else
    norm_local="$(normalize_version "$LOCAL_VERSION")"
    if [[ "$norm_remote" != "$norm_local" ]]; then
      if [[ "$(printf '%s\n%s\n' "$norm_local" "$norm_remote" | sort -V | tail -n1)" == "$norm_remote" ]]; then
        need_update=1
      fi
    fi
  fi
fi

if (( need_update )) && is_codex_installed_via_npm; then
  prefer_npm_update=1
fi

# If an update is needed but we don't yet have a download URL (e.g., version came from the API), fetch release metadata now.
if (( need_update )) && [[ -z "$remote_url" ]] && require_python; then
  tmp_payload="$(mktemp)"
  fetch_success=0
  candidate_tags=()
  add_tag() { local t="$1"; [[ -z "$t" ]] && return; for existing in "${candidate_tags[@]}"; do [[ "$existing" == "$t" ]] && return; done; candidate_tags+=("$t"); }
  add_tag "$remote_tag"
  add_tag "$remote_version"
  add_tag "v${remote_version}"
  add_tag "rust-${remote_version}"
  add_tag "rust-v${remote_version}"

  for tag_variant in "${candidate_tags[@]}"; do
    if payload_json="$(fetch_release_payload "${API_RELEASES_URL}/tags/${tag_variant}" "$asset_name" 2>/dev/null)"; then
      printf '%s\n' "$payload_json" > "$tmp_payload"
      if mapfile -t fresh_fields < <(read_cached_payload "$tmp_payload"); then
        remote_version="${fresh_fields[0]}"
        remote_url="${fresh_fields[1]}"
        remote_asset="${fresh_fields[2]}"
        remote_timestamp="${fresh_fields[3]}"
        remote_tag="${fresh_fields[4]}"
        fetch_success=1
        break
      fi
    fi
  done
  rm -f "$tmp_payload"
  if (( fetch_success == 0 )); then
    log_warn "Could not fetch release metadata for Codex ${remote_tag}"
  fi
fi

version_status=""
status_warn=0

if (( skip_update_check )); then
  version_status="status ok | local ${LOCAL_VERSION:-unknown} | update check skipped (not root)"
  if (( IS_ROOT )); then
    status_warn=1
  fi
elif (( need_update )) && [[ -n "$remote_url" ]]; then
  display_local="${LOCAL_VERSION:-unknown}"
  if (( prefer_npm_update )) && update_codex_via_npm "$norm_remote"; then
    hash -r
    CODEX_REAL_BIN="$(resolve_real_codex)"
    LOCAL_VERSION_RAW="$("$CODEX_REAL_BIN" -V 2>/dev/null || true)"
    LOCAL_VERSION="$(normalize_version "$LOCAL_VERSION_RAW")"
    LOCAL_VERSION_UNKNOWN=0
    version_status="status updated | ${display_local} → ${LOCAL_VERSION} (npm codex-cli @${norm_remote})"
  elif perform_update "$CODEX_REAL_BIN" "$remote_url" "${remote_asset:-$asset_name}" "$norm_remote"; then
    hash -r
    CODEX_REAL_BIN="$(resolve_real_codex)"
    LOCAL_VERSION_RAW="$("$CODEX_REAL_BIN" -V 2>/dev/null || true)"
    LOCAL_VERSION="$(normalize_version "$LOCAL_VERSION_RAW")"
    LOCAL_VERSION_UNKNOWN=0
    version_status="status updated | ${display_local} → ${LOCAL_VERSION} (from API ${remote_tag:-latest})"
  else
    status_warn=1
    version_status="status warn | local ${display_local} | update to ${norm_remote} failed"
  fi
else
  if [[ -n "$remote_version" ]]; then
    final_label="${remote_tag:-${remote_version}}"
    version_status="status ok | local ${LOCAL_VERSION:-unknown} | api ${final_label}"
  else
    status_warn=1
    version_status="status warn | local ${LOCAL_VERSION:-unknown} | API unavailable"
  fi
fi

if (( status_warn )); then
  log_warn "$version_status"
else
  log_info "$version_status"
fi

# Wrapper self-update (single latest version only)
wrapper_state="current (${WRAPPER_VERSION})"
if [[ "$AUTH_PULL_STATUS" == "ok" ]]; then
  target_wrapper="${SYNC_REMOTE_WRAPPER_VERSION:-${WRAPPER_VERSION}}"
  target_wrapper_sha="${SYNC_REMOTE_WRAPPER_SHA256:-}"
  target_wrapper_url="${SYNC_REMOTE_WRAPPER_URL:-}"
  if [[ -n "$target_wrapper_url" && "$target_wrapper_url" != http* ]]; then
    target_wrapper_url="${CODEX_SYNC_BASE_URL%/}${target_wrapper_url}"
  fi
  need_wrapper_update=0
  if [[ -n "$target_wrapper" && "$target_wrapper" != "$WRAPPER_VERSION" ]]; then
    need_wrapper_update=1
  fi
  if (( need_wrapper_update == 0 )) && [[ -n "$target_wrapper_sha" ]]; then
    if current_wrapper_sha="$(sha256sum "$SCRIPT_REAL" 2>/dev/null | awk '{print $1}')" && [[ -n "$current_wrapper_sha" ]]; then
      if [[ "$current_wrapper_sha" != "$target_wrapper_sha" ]]; then
        need_wrapper_update=1
      fi
    fi
  fi

  if (( need_wrapper_update )) && [[ -n "$target_wrapper_url" ]]; then
    if [[ -z "$CODEX_SYNC_API_KEY" ]]; then
      log_warn "Wrapper update skipped: API key missing"
    else
      tmpdir="$(mktemp -d)"
      tmpwrapper="$tmpdir/cdx"
      curl_args=(-fsSL -H "X-API-Key: $CODEX_SYNC_API_KEY")
      if [[ -n "$CODEX_SYNC_CA_FILE" ]]; then
        curl_args+=("--cacert" "$CODEX_SYNC_CA_FILE")
      fi
      if curl "${curl_args[@]}" "$target_wrapper_url" -o "$tmpwrapper"; then
        dl_sha="$(sha256sum "$tmpwrapper" | awk '{print $1}')"
        if [[ -n "$target_wrapper_sha" && "$dl_sha" != "$target_wrapper_sha" ]]; then
          log_warn "Wrapper update skipped: hash mismatch (expected ${target_wrapper_sha}, got ${dl_sha})"
        else
          chmod +x "$tmpwrapper"
          if [[ -w "$(dirname "$SCRIPT_REAL")" ]]; then
            install -m 755 "$tmpwrapper" "$SCRIPT_REAL"
            WRAPPER_VERSION="$target_wrapper"
            wrapper_state="updated (${WRAPPER_VERSION})"
          elif (( CAN_SUDO )); then
            if $SUDO_BIN install -m 755 "$tmpwrapper" "$SCRIPT_REAL"; then
              WRAPPER_VERSION="$target_wrapper"
              wrapper_state="updated (${WRAPPER_VERSION})"
            else
              log_warn "Wrapper update failed: sudo install denied"
            fi
          else
            log_warn "Wrapper update skipped: insufficient permissions to write $(dirname "$SCRIPT_REAL")"
          fi
        fi
      else
        log_warn "Wrapper update failed: download error"
      fi
      rm -rf "$tmpdir"
    fi
  elif (( need_wrapper_update )) && [[ -z "$target_wrapper_url" ]]; then
    log_warn "Wrapper update skipped: API did not provide download URL"
  fi
fi

# Condensed summary: always emit if auth pull succeeded (no verbose per-step lines)
build_status_summary() {
  local api_state="$1" codex_state="$2" cdx_state="$3"
  printf "Api %s | codex %s | cdx %s" "$api_state" "$codex_state" "$cdx_state"
}

if [[ "$AUTH_PULL_STATUS" == "ok" ]]; then
  target_version="${remote_tag:-${remote_version:-${LOCAL_VERSION:-unknown}}}"
  target_wrapper="${SYNC_REMOTE_WRAPPER_VERSION:-${WRAPPER_VERSION}}"
  codex_state="current (${LOCAL_VERSION})"
  if [[ "$LOCAL_VERSION" != "$target_version" ]]; then
    codex_state="needs update (${target_version}, local ${LOCAL_VERSION:-unknown})"
  fi
  cdx_state="current (${WRAPPER_VERSION}/${target_wrapper})"
  if [[ -n "$AUTH_STATUS" || -n "$AUTH_ACTION" || -n "$AUTH_MESSAGE" ]]; then
    log_info "Auth | ${AUTH_STATUS:-ok} | action=${AUTH_ACTION:-n/a}${AUTH_MESSAGE:+ | ${AUTH_MESSAGE}}"
  fi
  summary_text="$(build_status_summary "OK" "$codex_state" "$cdx_state")"
  log_info "$summary_text"
else
  summary_text="$(build_status_summary "FAIL" "auth unavailable" "current (${WRAPPER_VERSION}/${SYNC_REMOTE_WRAPPER_VERSION:-${WRAPPER_VERSION}})")"
  log_warn "$summary_text"
  log_error "Auth unavailable; refusing to start Codex. Re-run after fixing API key or provisioning auth."
  exit 1
fi

cleanup() {
  local exit_status=$?
  trap - EXIT
  if (( CODEX_COMMAND_STARTED )) && (( SYNC_PUSH_COMPLETED == 0 )); then
    push_auth_if_changed "push" || true
  fi
  # Emit final auth push status if determined
  if [[ -n "$AUTH_PUSH_RESULT" ]]; then
    log_info "Auth push | ${AUTH_PUSH_RESULT} | ${AUTH_PUSH_REASON:-n/a}"
  fi
  exit "$exit_status"
}
trap cleanup EXIT

if [[ "$AUTH_PULL_STATUS" != "ok" ]]; then
  exit 1
fi

run_codex_command() {
  local tmp_output status
  tmp_output="$(mktemp)"
  set +e
  if command -v script >/dev/null 2>&1 && [[ -t 1 ]]; then
    local cmd_line=("$CODEX_REAL_BIN" --ask-for-approval never --sandbox danger-full-access "$@")
    # Preserve a tty for interactive runs while still logging output for token parsing
    script -qfc "$(printf '%q ' "${cmd_line[@]}")" /dev/null | tee "$tmp_output"
    status=${PIPESTATUS[0]}
  else
    "$CODEX_REAL_BIN" --ask-for-approval never --sandbox danger-full-access "$@" 2>&1 | tee "$tmp_output"
    status=${PIPESTATUS[0]}
  fi
  set -e
  send_token_usage_if_present "$tmp_output"
  rm -f "$tmp_output"
  return "$status"
}

CODEX_COMMAND_STARTED=1
if run_codex_command "$@"; then
  cmd_status=0
else
  cmd_status=$?
fi
push_auth_if_changed "push" || true
exit "$cmd_status"

#!/usr/bin/env bash
# Generated by scripts/build-cdx.sh; edit bin/cdx.d/* and rebuild.
set -euo pipefail

# Fancy-ish log strings
if [[ -t 1 ]]; then
  BOLD="\033[1m"
  DIM="\033[2m"
  GREEN="\033[32m"
  YELLOW="\033[33m"
  ORANGE="\033[38;5;208m"
  CYAN="\033[96m"
  BLUE="\033[36m"
  MAGENTA="\033[35m"
  RED="\033[31m"
  RESET="\033[0m"
else
  BOLD=""
  DIM=""
  GREEN=""
  YELLOW=""
  ORANGE=""
  CYAN=""
  BLUE=""
  MAGENTA=""
  RED=""
  RESET=""
fi

log_info() { printf "%b» %s%b\n" "${BLUE}${BOLD}" "$1" "${RESET}"; }
log_warn() { printf "%b! %s%b\n" "${YELLOW}${BOLD}" "$1" "${RESET}" >&2; }
log_error() { printf "%bx %s%b\n" "${RED}${BOLD}" "$1" "${RESET}" >&2; }
log_debug() {
  (( CODEX_DEBUG )) && printf "%b[debug]%b %s\n" "${DIM}" "${RESET}" "$1" >&2
  return 0
}

MOTD_TEXT="$(cat <<'EOF'
  ██████╗ ██████╗ ██████╗ ███████╗██╗  ██╗
 ██╔════╝██╔═══██╗██╔══██╗██╔════╝╚██╗██╔╝
 ██║     ██║   ██║██║  ██║█████╗   ╚███╔╝ 
 ██║     ██║   ██║██║  ██║██╔══╝   ██╔██╗ 
 ╚██████╗╚██████╔╝██████╔╝███████╗██╔╝ ██╗
  ╚═════╝ ╚═════╝ ╚═════╝ ╚══════╝╚═╝  ╚═╝
                                           
  ██████╗ ██████╗  ██████╗ ██████╗ ██████╗ ██╗███╗   ██╗ █████╗ ████████╗ ██████╗ ██████╗ 
 ██╔════╝██╔═══██╗██╔═══██╗██╔══██╗██╔══██╗██║████╗  ██║██╔══██╗╚══██╔══╝██╔═══██╗██╔══██╗
 ██║     ██║   ██║██║   ██║██████╔╝██║  ██║██║██╔██╗ ██║███████║   ██║   ██║   ██║██████╔╝
 ██║     ██║   ██║██║   ██║██╔══██╗██║  ██║██║██║╚██╗██║██╔══██║   ██║   ██║   ██║██╔══██╗
 ╚██████╗╚██████╔╝╚██████╔╝██║  ██║██████╔╝██║██║ ╚████║██║  ██║   ██║   ╚██████╔╝██║  ██║
  ╚═════╝ ╚═════╝  ╚═════╝ ╚═╝  ╚═╝╚═════╝ ╚═╝╚═╝  ╚═══╝╚═╝  ╚═╝   ╚═╝    ╚═════╝ ╚═╝  ╚═╝
EOF
)"

print_motd() {
  while IFS= read -r line; do
    printf "%b %s%b\n" "${ORANGE}${BOLD}" "$line" "${RESET}"
  done <<<"$MOTD_TEXT"
}

mask_key() {
  local key="$1"
  if [[ -z "$key" ]]; then
    printf 'none'
    return
  fi
  local len=${#key}
  if (( len <= 8 )); then
    printf '%s' "$key"
  else
    printf '%s…%s' "${key:0:4}" "${key: -4}"
  fi
}

emit_insecure_notice() {
  (( HOST_SECURITY_NOTICE_EMITTED )) && return
  log_warn "Host marked insecure; auth.json will be removed after this run."
  log_warn "Bootstrap (insecure host): auth will not persist on disk."
  HOST_SECURITY_NOTICE_EMITTED=1
}

CODEX_DEBUG=${CODEX_DEBUG:-0}
CODEX_NO_PTY=${CODEX_NO_PTY:-0}
CODEX_NO_SCRIPT=${CODEX_NO_SCRIPT:-0}
CODEX_FORCE_WRAPPER_UPDATE=0
CODEX_EXIT_AFTER_UPDATE=0

# Per-host baked configuration (populated by the server at download time).
CODEX_SYNC_BASE_URL_DEFAULT="__CODEX_SYNC_BASE_URL__"
CODEX_SYNC_BASE_URL="$CODEX_SYNC_BASE_URL_DEFAULT"
CODEX_SYNC_API_KEY="__CODEX_SYNC_API_KEY__"
CODEX_SYNC_FQDN="__CODEX_SYNC_FQDN__"
CODEX_SYNC_CA_FILE="__CODEX_SYNC_CA_FILE__"
CODEX_HOST_SECURE="__CODEX_HOST_SECURE__"
if [[ "$CODEX_HOST_SECURE" == "__CODEX_HOST_SECURE__" ]]; then
  CODEX_HOST_SECURE="1"
fi
CODEX_FORCE_IPV4="__CODEX_FORCE_IPV4__"
if [[ "$CODEX_FORCE_IPV4" == "__CODEX_FORCE_IPV4__" ]]; then
  CODEX_FORCE_IPV4="0"
fi
CODEX_INSTALLATION_ID="__CODEX_INSTALLATION_ID__"
if [[ "$CODEX_INSTALLATION_ID" == "__CODEX_INSTALLATION_ID__" ]]; then
  CODEX_INSTALLATION_ID=""
fi
CODEX_SYNC_BAKED=1
CODEX_SYNC_ALLOW_INSECURE="${CODEX_SYNC_ALLOW_INSECURE:-0}"
export CODEX_SYNC_ALLOW_INSECURE
SYNC_CONFIG_LOADED=0
SYNC_WARNED_NO_PYTHON=0
CODEX_COMMAND_STARTED=0
SYNC_PUSH_COMPLETED=0
ORIGINAL_LAST_REFRESH=""
AUTH_PUSH_RESULT=""
AUTH_PUSH_REASON=""
AUTH_STATUS=""
AUTH_ACTION=""
AUTH_MESSAGE=""
SYNC_REMOTE_CLIENT_VERSION=""
SYNC_REMOTE_WRAPPER_VERSION=""
SYNC_REMOTE_WRAPPER_SHA256=""
SYNC_REMOTE_WRAPPER_URL=""
RUNNER_STATE=""
RUNNER_LAST_OK=""
RUNNER_LAST_FAIL=""
RUNNER_LAST_CHECK=""
RUNNER_ENABLED=0
AUTH_PULL_STATUS="skip"
AUTH_PULL_URL=""
LOCAL_AUTH_IS_FRESH=0
LOCAL_AUTH_IS_RECENT=0
last_usage_payload=""
CHATGPT_STATUS=""
CHATGPT_PLAN=""
CHATGPT_NEXT=""
CHATGPT_PRIMARY_USED=""
CHATGPT_PRIMARY_LIMIT=""
CHATGPT_PRIMARY_RESET_AFTER=""
CHATGPT_PRIMARY_RESET_AT=""
CHATGPT_SECONDARY_USED=""
CHATGPT_SECONDARY_LIMIT=""
CHATGPT_SECONDARY_RESET_AFTER=""
CHATGPT_SECONDARY_RESET_AT=""
QUOTA_BLOCKED=0
QUOTA_BLOCK_REASON=""
QUOTA_WARNING=0
QUOTA_WARNING_REASON=""
QUOTA_HARD_FAIL="${CODEX_QUOTA_HARD_FAIL:-1}"
HOST_SECURE="$CODEX_HOST_SECURE"
HOST_IS_SECURE=1
PURGE_AUTH_AFTER_RUN=0
HOST_SECURITY_NOTICE_EMITTED=0
HOST_API_CALLS=""
HOST_TOKENS_MONTH_TOTAL=""
HOST_TOKENS_MONTH_INPUT=""
HOST_TOKENS_MONTH_OUTPUT=""
HOST_TOKENS_MONTH_CACHED=""
HOST_TOKENS_MONTH_REASONING=""
HOST_TOKENS_MONTH_EVENTS=""
PROMPT_DIR="$HOME/.codex/prompts"
PROMPT_BASELINE_FILE="$HOME/.codex/.prompt-baseline.json"
PROMPT_SYNC_STATUS="skip"
PROMPT_PULL_UPDATED=0
PROMPT_PULL_ERRORS=0
PROMPT_PUSHED=0
PROMPT_PUSH_ERRORS=0
PROMPT_PUSH_STATUS=""
PROMPT_REMOTE_COUNT=""
PROMPT_LOCAL_COUNT=""
PROMPT_LOCAL_CHANGED=""
PROMPT_REMOVED=0

if [[ "$HOST_SECURE" == "0" || "${HOST_SECURE,,}" == "false" ]]; then
  HOST_IS_SECURE=0
  PURGE_AUTH_AFTER_RUN=1
  emit_insecure_notice
fi

WRAPPER_VERSION="2025.11.29-06"
MAX_LOCAL_AUTH_AGE_SECONDS=$((24 * 3600))
MAX_LOCAL_AUTH_RECENT_SECONDS=$((7 * 24 * 3600))
RUNNER_STALE_WARN_SECONDS=$((36 * 3600))
RUNNER_STALE_CRIT_SECONDS=$((72 * 3600))

IS_ROOT=0
CAN_SUDO=0
SUDO_BIN="sudo -n"
if (( EUID == 0 )); then
  IS_ROOT=1
elif command -v sudo >/dev/null 2>&1; then
  if sudo -n true >/dev/null 2>&1; then
    CAN_SUDO=1
  fi
fi

CURRENT_USER="$(id -un 2>/dev/null || echo unknown)"
LOCAL_HOSTNAME="$(hostname -f 2>/dev/null || hostname 2>/dev/null || echo unknown)"
HOST_USERS_CACHE=()
HOST_USERS_FETCHED=0

# Early one-shot commands
case "${1-}" in
  --wrapper-version|-W)
    printf 'cdx wrapper %s\n' "$WRAPPER_VERSION"
    exit 0
    ;;
  --uninstall)
    cmd_uninstall
    ;;
  --update|-U)
    CODEX_FORCE_WRAPPER_UPDATE=1
    CODEX_EXIT_AFTER_UPDATE=1
    shift
    ;;
esac

case "${1-}" in
  --debug|--verbose)
    CODEX_DEBUG=1
    shift
    ;;
esac

if (( ! IS_ROOT )) && (( CAN_SUDO == 0 )); then
  log_info "Non-root execution detected; skipping automatic Codex install/update (passwordless sudo required)."
fi
log_debug "starting | user=${CURRENT_USER} | is_root=${IS_ROOT} | can_sudo=${CAN_SUDO} | path=$PATH"

detect_linux_package_manager() {
  local tokens=()
  if [[ -r /etc/os-release ]]; then
    # shellcheck disable=SC1091
    . /etc/os-release
    if [[ -n "${ID:-}" ]]; then
      tokens+=("$ID")
    fi
    if [[ -n "${ID_LIKE:-}" ]]; then
      local like
      for like in $ID_LIKE; do
        tokens+=("$like")
      done
    fi
  fi
  local token
  for token in "${tokens[@]}"; do
    case "$token" in
      debian|ubuntu)
        if command -v apt-get >/dev/null 2>&1; then
          printf '%s' apt-get
          return 0
        fi
        ;;
      rhel|centos|fedora|almalinux|rocky|ol)
        if command -v dnf >/dev/null 2>&1; then
          printf '%s' dnf
          return 0
        fi
        ;;
    esac
  done
  if command -v apt-get >/dev/null 2>&1; then
    printf '%s' apt-get
    return 0
  fi
  if command -v dnf >/dev/null 2>&1; then
    printf '%s' dnf
    return 0
  fi
  return 1
}

with_sudo() {
  if (( EUID == 0 )); then
    "$@"
  elif command -v sudo >/dev/null 2>&1; then
    sudo "$@"
  else
    return 1
  fi
}

remove_path() {
  local path="$1"
  local label="$2"
  [[ -z "$path" || "$path" == "/" ]] && return 0
  if rm -rf "$path" 2>/dev/null; then
    log_info "Removed $label ($path)"
    return 0
  fi
  if with_sudo rm -rf "$path" 2>/dev/null; then
    log_info "Removed $label ($path) with sudo"
    return 0
  fi
  log_warn "Unable to remove $label ($path)"
  return 1
}

maybe_home() {
  local user="$1"
  local home=""
  if command -v getent >/dev/null 2>&1; then
    home="$(getent passwd "$user" | cut -d: -f6 2>/dev/null || true)"
  fi
  [[ -z "$home" ]] && home="/home/$user"
  printf '%s\n' "$home"
}

uninstall_api_deregister() {
  local base="${CODEX_SYNC_BASE_URL%/}"
  local key="$CODEX_SYNC_API_KEY"
  local cafile="$CODEX_SYNC_CA_FILE"
  if [[ -z "$base" || -z "$key" ]]; then
    log_warn "Skipping API deregistration (missing base URL or API key)"
    return
  fi
  local url="${base}/auth?force=1"
  local args=(-fsS -X DELETE -H "X-API-Key: ${key}")
  [[ -n "$cafile" ]] && args+=(--cacert "$cafile")
  if curl "${args[@]}" "$url" >/dev/null 2>&1; then
    log_info "API deregistration succeeded"
  else
    log_warn "API deregistration failed (continuing cleanup)"
  fi
}

record_host_user_with_api() {
  load_sync_config
  local base="${CODEX_SYNC_BASE_URL%/}"
  local key="$CODEX_SYNC_API_KEY"
  local cafile="$CODEX_SYNC_CA_FILE"
  if [[ -z "$base" || -z "$key" ]]; then
    return 1
  fi
  local hostname="$LOCAL_HOSTNAME"
  [[ -z "$hostname" || "$hostname" == "unknown" ]] && hostname="$(hostname 2>/dev/null || echo unknown)"

  local payload
  if ! payload="$(USERNAME="$CURRENT_USER" HOSTNAME="$hostname" python3 - <<'PY' 2>/dev/null
import json, os, sys
user = os.environ.get("USERNAME", "").strip()
host = os.environ.get("HOSTNAME", "").strip()
print(json.dumps({"username": user, "hostname": host}, ensure_ascii=False))
PY
)"; then
    return 1
  fi

  local url="${base}/host/users"
  local args=(-fsS -X POST -H "X-API-Key: ${key}" -H "Content-Type: application/json" --data "$payload")
  [[ -n "$cafile" ]] && args+=(--cacert "$cafile")
  local response=""
  if ! response="$(curl "${args[@]}" "$url" 2>/dev/null)"; then
    return 1
  fi

  local parsed_users=()
  if mapfile -t parsed_users < <(API_RESPONSE="$response" python3 - <<'PY' 2>/dev/null
import json, os
data = os.environ.get("API_RESPONSE", "")
parsed = json.loads(data)
users = parsed.get("data", {}).get("users")
if not isinstance(users, list):
    raise SystemExit(1)
seen = set()
for entry in users:
    username = None
    if isinstance(entry, dict):
        username = entry.get("username")
    elif isinstance(entry, str):
        username = entry
    if not username:
        continue
    username = str(username).strip()
    if not username or username in seen:
        continue
    seen.add(username)
    print(username)
PY
); then
    parsed_users=()
  fi
  HOST_USERS_CACHE=("${parsed_users[@]}")
  HOST_USERS_FETCHED=1
  return 0
}

cmd_uninstall() {
  log_info "Starting Codex uninstall"
  load_sync_config
  record_host_user_with_api || true
  uninstall_api_deregister

  # Legacy env/config files
  remove_path "/usr/local/etc/codex-sync.env" "sync env (system)"
  remove_path "/etc/codex-sync.env" "sync env (system-legacy)"
  remove_path "$HOME/.codex/sync.env" "sync env (user)"

  # Auth + state per user (from API fallback to current user)
  local users=()
  if (( ${#HOST_USERS_CACHE[@]} == 0 )); then
    users+=("$CURRENT_USER")
  else
    users+=("${HOST_USERS_CACHE[@]}")
  fi
  local ensured_current=0
  local u
  for u in "${users[@]}"; do
    [[ "$u" == "$CURRENT_USER" ]] && ensured_current=1 && break
  done
  (( ensured_current )) || users+=("$CURRENT_USER")

  local seen=()
  local home
  for u in "${users[@]}"; do
    local skip=0
    for existing in "${seen[@]}"; do
      [[ "$existing" == "$u" ]] && skip=1 && break
    done
    (( skip )) && continue
    seen+=("$u")
    home="$(maybe_home "$u")"
    [[ ! -d "$home" ]] && continue
    remove_path "$home/.codex/auth.json" "auth.json for $u"
    remove_path "$home/.codex" ".codex dir for $u"
  done

  # Binaries and install dirs
  remove_path "/usr/local/bin/cdx" "cdx binary"
  remove_path "$HOME/.local/bin/cdx" "cdx binary (user)"
  remove_path "/usr/local/bin/codex" "codex binary"
  remove_path "$HOME/.local/bin/codex" "codex binary (user)"
  remove_path "/opt/codex" "/opt/codex directory"

  # NPM global package (best effort)
  if command -v npm >/dev/null 2>&1; then
    if npm list -g codex-cli --depth=0 >/dev/null 2>&1; then
      if (( EUID == 0 )); then
        npm uninstall -g codex-cli >/dev/null 2>&1 || log_warn "npm uninstall codex-cli failed"
      else
        with_sudo npm uninstall -g codex-cli >/dev/null 2>&1 || npm uninstall -g codex-cli >/dev/null 2>&1 || log_warn "npm uninstall codex-cli failed"
      fi
      log_info "Removed npm codex-cli (if present)"
    fi
  fi

  log_info "Codex uninstall complete"
  exit 0
}

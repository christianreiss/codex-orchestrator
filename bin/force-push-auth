#!/usr/bin/env bash
set -euo pipefail

# Force-push the local ~/.codex/auth.json to the Codex sync API.
# Use this when canonical state needs to be replaced quickly.

DEFAULT_BASE_URL="https://codex-auth.uggs.io"
AUTH_PATH="${AUTH_PATH:-$HOME/.codex/auth.json}"
CA_FILE="${CODEX_SYNC_CA_FILE:-}"
BASE_URL="${CODEX_SYNC_BASE_URL:-$DEFAULT_BASE_URL}"
API_KEY="${CODEX_SYNC_API_KEY:-}"
INVITE_KEY="${CODEX_SYNC_INVITE_KEY:-}"
FQDN="${CODEX_SYNC_FQDN:-$(hostname -f 2>/dev/null || hostname 2>/dev/null || echo localhost)}"
SYNC_ENV_PATHS=("$HOME/.codex/sync.env" "/usr/local/etc/codex-sync.env" "/etc/codex-sync.env")

usage() {
  cat <<'USAGE'
Usage: force-push-auth [options]
  --base-url <url>     Sync API base URL (default: env CODEX_SYNC_BASE_URL or https://codex-auth.uggs.io)
  --api-key <key>      Existing API key (skip registration)
  --invite-key <key>   Invitation key for /register (needed when no API key)
  --invite-file <path> Read invitation key from file
  --fqdn <name>        FQDN to register as (default: system hostname)
  --auth <path>        Path to auth.json (default: ~/.codex/auth.json)
  --ca-file <path>     Custom CA bundle for TLS
  --help               Show this help
Environment falls back to CODEX_SYNC_* vars or existing sync env files.
USAGE
  exit "${1:-0}"
}

log() { printf '==> %s\n' "$1"; }
die() { printf 'Error: %s\n' "$1" >&2; exit 1; }

parse_env_file() {
  local file="$1"
  [[ -r "$file" ]] || return 0
  while IFS='=' read -r key value; do
    value="${value%$'\r'}"
    case "$key" in
      CODEX_SYNC_BASE_URL) [[ -z "$BASE_URL" || "$BASE_URL" == "$DEFAULT_BASE_URL" ]] && BASE_URL="${value%/}" ;;
      CODEX_SYNC_API_KEY)  [[ -z "$API_KEY" ]] && API_KEY="$value" ;;
      CODEX_SYNC_FQDN)     [[ -z "$FQDN" ]] && FQDN="$value" ;;
      CODEX_SYNC_CA_FILE)  [[ -z "$CA_FILE" ]] && CA_FILE="$value" ;;
    esac
  done <"$file"
}

while [[ $# -gt 0 ]]; do
  case "$1" in
    --base-url) BASE_URL="${2%/}"; shift 2 ;;
    --api-key) API_KEY="$2"; shift 2 ;;
    --invite-key) INVITE_KEY="$2"; shift 2 ;;
    --invite-file) INVITE_KEY="$(<"$2")"; shift 2 ;;
    --fqdn) FQDN="$2"; shift 2 ;;
    --auth) AUTH_PATH="$2"; shift 2 ;;
    --ca-file) CA_FILE="$2"; shift 2 ;;
    -h|--help) usage 0 ;;
    *) die "Unknown option: $1" ;;
  esac
done

for envpath in "${SYNC_ENV_PATHS[@]}"; do
  parse_env_file "$envpath"
done

[[ -n "$BASE_URL" ]] || die "Base URL required"
[[ -r "$AUTH_PATH" ]] || die "auth.json not found at $AUTH_PATH"

# Try to read invite key from project .env if not provided
if [[ -z "$INVITE_KEY" && -r "$(dirname "$0")/../.env" ]]; then
  INVITE_KEY="$(grep -E '^INVITATION_KEY=' "$(dirname "$0")/../.env" | tail -n1 | cut -d= -f2- || true)"
fi

register_host() {
  [[ -n "$INVITE_KEY" ]] || die "Invitation key required to register"
  local body payload
  payload="$(printf '{"fqdn":"%s","invitation_key":"%s"}' "$FQDN" "$INVITE_KEY")"
  body="$(curl -fsS ${CA_FILE:+--cacert "$CA_FILE"} \
    -H 'Content-Type: application/json' \
    -d "$payload" \
    "${BASE_URL}/register")" || die "Register failed"
  API_KEY="$(printf '%s' "$body" | jq -r '.host.api_key // .data.host.api_key // empty')"
  [[ -n "$API_KEY" ]] || die "Register response missing api_key"
  log "Registered $FQDN and obtained API key"
}

[[ -n "$API_KEY" ]] || register_host

# Build canonical auth payload in Python to tolerate different auth.json shapes.
PAYLOAD="$(python3 - <<'PY'
import json, os, sys, datetime, pathlib

auth_path = pathlib.Path(os.environ["AUTH_PATH"])
base_url = os.environ["BASE_URL"].rstrip("/")
api_key = os.environ["API_KEY"]
client_version = os.environ.get("CLIENT_VERSION", "unknown")
wrapper_version = os.environ.get("WRAPPER_VERSION", "unknown")
now = datetime.datetime.now(datetime.timezone.utc).isoformat().replace("+00:00", "Z")

def load_auth():
    try:
        data = json.loads(auth_path.read_text(encoding="utf-8"))
        if isinstance(data, dict):
            return data
    except Exception:
        pass
    return {}

raw = load_auth()
last_refresh = raw.get("last_refresh")
if not isinstance(last_refresh, str) or not last_refresh.strip():
    last_refresh = now

# Prefer existing auths if present; otherwise synthesize from access_token.
auths = raw.get("auths") if isinstance(raw.get("auths"), dict) else None
if not auths:
    tokens = raw.get("tokens") if isinstance(raw.get("tokens"), dict) else {}
    access = tokens.get("access_token")
    if isinstance(access, str) and access.strip():
        auths = {"api.openai.com": {"token": access.strip()}}
    else:
        print("Local auth.json missing auths and access_token; cannot push", file=sys.stderr)
        sys.exit(3)

payload = {
    "command": "store",
    "client_version": client_version,
    "wrapper_version": wrapper_version,
    "auth": {
        "last_refresh": last_refresh,
        "auths": auths,
    },
}
print(json.dumps(payload, separators=(",", ":")))
PY
)" || exit $?

log "Pushing auth.json to ${BASE_URL}/auth"
curl -fsS ${CA_FILE:+--cacert "$CA_FILE"} \
  -H "Content-Type: application/json" \
  -H "X-API-Key: ${API_KEY}" \
  -d "$PAYLOAD" \
  "${BASE_URL}/auth" | jq .

log "Force push completed"

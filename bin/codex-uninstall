#!/usr/bin/env bash
set -euo pipefail

usage() {
  cat >&2 <<'USAGE'
Usage: codex-uninstall [options] [<host|[user@]host>]

Options:
  -u, --user <ssh_user>       SSH user when host is provided without user (default: root)
  -p, --ssh-port <port>       SSH port (default: 22)
  -i, --identity <path>       SSH identity file
      --ssh-opt <arg>         Extra ssh option (repeatable)
  -S, --sudo                  Use sudo on remote host when removing system files
  -v, --verbose               Verbose output from remote uninstall routine
  -h, --help                  Show this help and exit
USAGE
  exit "${1:-2}"
}

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
REPO_ROOT="$(cd "${SCRIPT_DIR}/.." && pwd)"

SSH_USER="root"
SSH_PORT=22
IDENTITY_FILE=""
SSH_EXTRA_OPTS=()
USE_SUDO=0
VERBOSE=0
TARGET_HOST=""

while [ $# -gt 0 ]; do
  case "$1" in
    -u|--user)
      [ $# -ge 2 ] || usage
      SSH_USER="$2"
      shift 2
      ;;
    -p|--ssh-port)
      [ $# -ge 2 ] || usage
      SSH_PORT="$2"
      shift 2
      ;;
    -i|--identity)
      [ $# -ge 2 ] || usage
      IDENTITY_FILE="$2"
      shift 2
      ;;
    --ssh-opt)
      [ $# -ge 2 ] || usage
      SSH_EXTRA_OPTS+=("$2")
      shift 2
      ;;
    -S|--sudo)
      USE_SUDO=1
      shift
      ;;
    -v|--verbose)
      VERBOSE=1
      shift
      ;;
    -h|--help)
      usage 0
      ;;
    --)
      shift
      if [ $# -eq 0 ]; then
        usage
      fi
      TARGET_HOST="$1"
      shift
      ;;
    -* )
      usage
      ;;
    *)
      if [ -n "$TARGET_HOST" ]; then
        usage
      fi
      TARGET_HOST="$1"
      shift
      ;;
  esac
done

if [ -z "$TARGET_HOST" ]; then
  usage
fi

TARGETS=()
if [ -n "$TARGET_HOST" ]; then
  TARGETS+=("$TARGET_HOST")
fi

if [ ${#TARGETS[@]} -gt 0 ]; then
  declare -A seen_targets=()
  unique_targets=()
  for target in "${TARGETS[@]}"; do
    [ -n "$target" ] || continue
    if [ -z "${seen_targets[$target]+x}" ]; then
      seen_targets[$target]=1
      unique_targets+=("$target")
    fi
  done
  TARGETS=("${unique_targets[@]}")
fi

if [ ${#TARGETS[@]} -eq 0 ]; then
  printf 'No targets specified\n' >&2
  exit 1
fi

SSH_BASE_OPTS=(-o ExitOnForwardFailure=yes -o ServerAliveInterval=60 -o ForwardAgent=yes -o LogLevel=ERROR -p "$SSH_PORT")
if [ -n "$IDENTITY_FILE" ]; then
  SSH_BASE_OPTS+=(-i "$IDENTITY_FILE")
fi
if [ ${#SSH_EXTRA_OPTS[@]} -gt 0 ]; then
  SSH_BASE_OPTS+=("${SSH_EXTRA_OPTS[@]}")
fi

REMOTE_ENV_STR() {
  local parts=()
  parts+=("USE_SUDO=$(printf %q "$USE_SUDO")")
  parts+=("VERBOSE=$(printf %q "$VERBOSE")")
  printf '%s' "${parts[*]}"
}

read -r -d '' REMOTE_CMD <<'EOCMD' || true
set -euo pipefail

log() { printf '[remote] %s\n' "$*"; }
warn() { printf '[remote][WARN] %s\n' "$*" >&2; }
have() { command -v "$1" >/dev/null 2>&1; }

timestamp() { date +'%Y-%m-%dT%H:%M:%SZ'; }

USE_SUDO="${USE_SUDO:-0}"
VERBOSE="${VERBOSE:-0}"

declare -a REMOVED_ITEMS=()
declare -a FAILED_ITEMS=()

SYNC_BASE_URL=""
SYNC_API_KEY=""
SYNC_CA_FILE=""

record_removed() { REMOVED_ITEMS+=("$1"); }
record_failed() { FAILED_ITEMS+=("$1"); }

try_run() {
  local need_priv="$1"
  shift
  if "$@" >/dev/null 2>&1; then
    return 0
  fi
  if [ "$need_priv" -eq 1 ] && [ "$USE_SUDO" -eq 1 ] && have sudo; then
    if sudo "$@" >/dev/null 2>&1; then
      return 0
    fi
  fi
  return 1
}

user_exists() {
  id "$1" >/dev/null 2>&1
}

user_home_dir() {
  local user="$1"
  local home=""
  if have getent; then
    home=$(getent passwd "$user" | cut -d: -f6 2>/dev/null || true)
  fi
  if [ -z "$home" ] && [ -r /etc/passwd ]; then
    home=$(awk -F: -v u="$user" '($1==u){print $6; exit}' /etc/passwd 2>/dev/null || true)
  fi
  if [ -z "$home" ]; then
    case "$user" in
      root) home="/root" ;;
      *) home="/home/$user" ;;
    esac
  fi
  printf '%s\n' "$home"
}

strip_quotes() {
  local v="$1"
  v="${v%$'\r'}"
  v="${v#"${v%%[![:space:]]*}"}"
  v="${v%"${v##*[![:space:]]}"}"
  v="${v#\"}"; v="${v%\"}"
  v="${v#\'}"; v="${v%\'}"
  printf '%s' "$v"
}

load_sync_env() {
  local path key value found=0
  for path in /usr/local/etc/codex-sync.env "$HOME/.codex/sync.env" "/root/.codex/sync.env"; do
    if [ -r "$path" ]; then
      found=1
      while IFS='=' read -r key value; do
        key="${key%%[[:space:]]*}"
        case "$key" in
          ""|\#*) continue ;;
        esac
        value="$(strip_quotes "$value")"
        case "$key" in
          CODEX_SYNC_BASE_URL) SYNC_BASE_URL="$value" ;;
          CODEX_SYNC_API_KEY) SYNC_API_KEY="$value" ;;
          CODEX_SYNC_CA_FILE) SYNC_CA_FILE="$value" ;;
        esac
      done <"$path"
      if [ -n "$SYNC_BASE_URL" ] && [ -n "$SYNC_API_KEY" ]; then
        log "Loaded sync config from $path"
        return 0
      fi
    fi
  done
  if [ "$found" -eq 1 ]; then
    warn "Sync config found but missing base URL or API key"
  fi
  return 1
}

delete_host_from_api() {
  if [ -z "$SYNC_BASE_URL" ] || [ -z "$SYNC_API_KEY" ]; then
    return 0
  fi

  local url="${SYNC_BASE_URL%/}/auth?force=1"
  if have curl; then
    local args=("--silent" "--show-error" "--fail" "-X" "DELETE" "-H" "X-API-Key: ${SYNC_API_KEY}")
    if [ -n "$SYNC_CA_FILE" ] && [ -r "$SYNC_CA_FILE" ]; then
      args+=("--cacert" "$SYNC_CA_FILE")
    fi
    if curl "${args[@]}" "$url" >/dev/null 2>&1; then
      log "API deregistration succeeded ($url)"
      return 0
    fi
    warn "API deregistration failed via curl ($url)"
    return 0
  fi

  if have python3; then
    if python3 - "$url" "$SYNC_API_KEY" "$SYNC_CA_FILE" <<'PY'; then
import ssl
import sys
import urllib.request

url = sys.argv[1]
api_key = sys.argv[2]
cafile = sys.argv[3] if len(sys.argv) > 3 else ""

ctx = ssl.create_default_context()
if cafile:
    try:
        ctx.load_verify_locations(cafile)
    except Exception:
        pass

req = urllib.request.Request(url, headers={"X-API-Key": api_key}, method="DELETE")
try:
    with urllib.request.urlopen(req, timeout=10, context=ctx) as resp:
        sys.exit(0 if resp.status < 400 else 1)
except Exception:
    sys.exit(1)
PY
    then
      log "API deregistration succeeded (python, $url)"
    else
      warn "API deregistration failed via python ($url)"
    fi
    return 0
  fi

  warn "API deregistration skipped (curl/python3 unavailable)"
  return 0
}

remove_file() {
  local path="$1"
  local label="$2"
  local need_priv="$3"
  if [ -e "$path" ]; then
    if try_run "$need_priv" rm -f "$path"; then
      record_removed "$label"
    else
      record_failed "$label"
    fi
  fi
}

remove_dir() {
  local path="$1"
  local label="$2"
  local need_priv="$3"
  if [ -d "$path" ]; then
    if try_run "$need_priv" rm -rf "$path"; then
      record_removed "$label"
    else
      record_failed "$label"
    fi
  fi
}

remove_auth_for_user() {
  local user="$1"
  if ! user_exists "$user"; then
    return 0
  fi
  local home
  home="$(user_home_dir "$user")"
  local auth_path="$home/.codex/auth.json"
  local dir_path="$home/.codex"
  local need_priv=0
  if [ "$user" != "$(id -un)" ]; then
    need_priv=1
  fi
  remove_file "$auth_path" "auth.json for $user" "$need_priv"
  # clean sync config on the user scope as well
  local sync_env="$home/.codex/sync.env"
  local sync_ca="$home/.codex/sync-ca.pem"
  remove_file "$sync_env" "sync env for $user" "$need_priv"
  remove_file "$sync_ca" "sync CA for $user" "$need_priv"
  remove_dir "$dir_path" ".codex dir for $user" "$need_priv"
}

load_sync_env || true
delete_host_from_api || true

remove_file "/usr/local/bin/cdx" "/usr/local/bin/cdx" 1
remove_file "/usr/local/bin/codex" "/usr/local/bin/codex" 1
remove_file "/usr/bin/codex" "/usr/bin/codex" 1
remove_dir "/opt/codex" "/opt/codex" 1
remove_dir "/usr/local/lib/codex" "/usr/local/lib/codex" 1

remove_file "/usr/local/etc/codex-sync.env" "sync env (/usr/local/etc)" 1
remove_file "/usr/local/etc/codex-sync-ca.pem" "sync CA (/usr/local/etc)" 1

remove_file "$HOME/.local/bin/cdx" "local cdx" 0
remove_file "$HOME/cdx.sh" "$HOME/cdx.sh" 0
remove_file "$HOME/codex.sh" "$HOME/codex.sh" 0

remove_auth_for_user "$(id -un)"
if user_exists root; then
  remove_auth_for_user root
fi
if user_exists chris; then
  remove_auth_for_user chris
fi

if [ ${#REMOVED_ITEMS[@]} -gt 0 ]; then
  log "Removed: ${REMOVED_ITEMS[*]}"
fi
if [ ${#FAILED_ITEMS[@]} -gt 0 ]; then
  warn "Failed: ${FAILED_ITEMS[*]}"
  exit 1
fi

log "Uninstall completed at $(timestamp)"
EOCMD

REMOTE_CMD_ESCAPED="$(printf %q "$REMOTE_CMD")"

run_uninstall() {
  local target="$1"
  local ssh_user="$SSH_USER"
  local host="$target"

  if [[ "$target" == *"@"* ]]; then
    ssh_user="${target%@*}"
    host="${target#*@}"
  fi

  if [ -z "$ssh_user" ] || [ -z "$host" ]; then
    printf 'Invalid target %s\n' "$target" >&2
    return 1
  fi

  local remote_env
  remote_env="$(REMOTE_ENV_STR)"

  printf '==> Uninstalling Codex on %s@%s\n' "$ssh_user" "$host"
  if ! ssh -tt "${SSH_BASE_OPTS[@]}" "$ssh_user@$host" "${remote_env} bash -lc ${REMOTE_CMD_ESCAPED}"; then
    printf '!! Uninstall failed on %s@%s\n' "$ssh_user" "$host" >&2
    return 1
  fi
  printf '==> Completed %s@%s\n' "$ssh_user" "$host"
  return 0
}

SUCCESS_TARGETS=()
FAILED_TARGETS=()

for target in "${TARGETS[@]}"; do
  if run_uninstall "$target"; then
    SUCCESS_TARGETS+=("$target")
  else
    FAILED_TARGETS+=("$target")
  fi
  printf '\n'
  sleep 0.2 || true
done

if [ ${#FAILED_TARGETS[@]} -gt 0 ]; then
  printf 'Completed with failures. Failed targets:\n' >&2
  printf '  %s\n' "${FAILED_TARGETS[@]}" >&2
  exit 1
fi

printf 'Uninstall succeeded for all targets:\n'
printf '  %s\n' "${SUCCESS_TARGETS[@]}"
